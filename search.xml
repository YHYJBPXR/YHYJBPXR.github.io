<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CTF中常见的编码方式和加密方法（正在施工中）</title>
    <url>/2023/05/01/CTF%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F%E5%92%8C%E5%8A%A0%E5%AF%86%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>一些基础知识，了解即可</p>
<span id="more"></span>

<h1 id="CTF常见的加密方式与编码方法总结（正在施工中）"><a href="#CTF常见的加密方式与编码方法总结（正在施工中）" class="headerlink" title="CTF常见的加密方式与编码方法总结（正在施工中）"></a>CTF常见的加密方式与编码方法总结（正在施工中）</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="2、4、8、16进制（自己了解下吧，感觉这块中学基础应该有）"><a href="#2、4、8、16进制（自己了解下吧，感觉这块中学基础应该有）" class="headerlink" title="2、4、8、16进制（自己了解下吧，感觉这块中学基础应该有）"></a>2、4、8、16进制（自己了解下吧，感觉这块中学基础应该有）</h3><h3 id="计算机内部处理数字的方式"><a href="#计算机内部处理数字的方式" class="headerlink" title="计算机内部处理数字的方式"></a>计算机内部处理数字的方式</h3><p><a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/computercode.html">原码, 反码, 补码 详解 - ziqiu.zhang - 博客园</a></p>
<h3 id="字符集和字符编码"><a href="#字符集和字符编码" class="headerlink" title="字符集和字符编码"></a>字符集和字符编码</h3><p>字符集和字符编码是计算机科学中的两个相关概念，它们通常一起使用来表示和处理文本数据。</p>
<p><strong>字符集</strong>是一组预定义的<strong>字符</strong>，每个字符都有一个唯一的标识符。例如，ASCII字符集定义了128个字符，包括字母、数字、标点符号和控制字符等。Unicode字符集则定义了超过100,000个字符，包括世界上大多数语言的字母、符号和表情符号等。</p>
<p><strong>字符编码</strong>是将字符集中的每个字符转换为计算机能够处理的数字编码的<strong>过程</strong>。计算机只能处理二进制数字，因此需要将字符集中的字符转换为二进制数字才能存储和处理。例如，ASCII编码将每个字符映射到一个7位的二进制数，范围从0到127。Unicode编码则使用不同的方案，其中UTF-8编码是最常用的一种方式。UTF-8编码使用1到4个字节来表示Unicode字符，这使得它可以支持超过1百万种字符。</p>
<p>可以这么理解，字符集是一个集合，字符编码是把字符对应到二进制数的一个映射。字符集定义了可用的字符集合，而字符编码定义了如何将这些字符转换为计算机能够处理的数字编码。</p>
<p>在实际应用中，字符集和字符编码往往被视为一个整体，通常使用术语“字符编码”来指代它们的组合。</p>
<h3 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h3><p><a href="https://zh.wikipedia.org/wiki/ASCII">ASCII - 维基百科，自由的百科全书</a></p>
<h2 id="Base编码"><a href="#Base编码" class="headerlink" title="Base编码"></a>Base编码</h2><h3 id="Base编码的历史"><a href="#Base编码的历史" class="headerlink" title="Base编码的历史"></a>Base编码的历史</h3><p><a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc4648.txt.pdf">Enscript Output (rfc-editor.org)</a></p>
<p>Base编码是一种<strong>将二进制数据转换为文本形式的编码方式</strong>，最初用于电子邮件传输。因为之前的电子邮件系统当初是为了传输 7 位 ASCII 文本而设计的，只能传输文本数据，不能传输二进制数据，此外不同邮件网关会对接收到的信息进行不同处理，就会导致信息不完整等问题。</p>
<p>因此，需要一种方法将二进制数据转换为文本数据，以便能够通过邮件系统进行传输。</p>
<p>在1973年，Robert J. Haskins开发了一种基于64个字符的编码方式，称为Radix-64编码。这种编码方式使用了26个大写字母、26个小写字母、10个数字和2个特殊符号（+和/），共计64个字符。Radix-64编码将3个8位的二进制数据块转换为4个6位的字符，因此<strong>可以将任意二进制数据编码为可打印的ASCII字符</strong>。Radix-64编码在后来的邮件系统中得到了广泛应用，成为了电子邮件传输中的标准编码方式。</p>
<p>在1990年代，Base编码成为了因特网传输中的常用编码方式之一。Base64编码是Radix-64编码的一种变种，它将3个8位的二进制数据块转换为4个6位的字符，使用的字符集为A-Z、a-z、0-9和两个特殊符号（+和/）。Base64编码在Web应用中得到广泛应用，例如将图片和其他二进制数据嵌入HTML代码中进行传输。</p>
<p>除了Base64编码外，还有许多其他的Base编码方式，例如Base16、Base32等。这些编码方式使用的字符集和编码算法都不同，但它们的基本原理相同，即将<strong>二进制数据转换为文本数据</strong>以便进行传输。</p>
<h3 id="Base编码的原理"><a href="#Base编码的原理" class="headerlink" title="Base编码的原理"></a>Base编码的原理</h3><p><a href="https://www.cnblogs.com/0yst3r-2046/p/11962942.html">Base系列编码浅析【base16 base32 base64 base85 base36 base 58 base91 base 92 base62】 - 0yst3r - 博客园</a></p>
<h3 id="Base编码的工具"><a href="#Base编码的工具" class="headerlink" title="Base编码的工具"></a>Base编码的工具</h3><p><a href="https://ctf.bugku.com/tools">在线工具 - Bugku CTF</a></p>
<p><a href="https://github.com/mufeedvh/basecrack">mufeedvh/basecrack: Decode All Bases - Base Scheme Decoder</a></p>
<h3 id="在python中实现"><a href="#在python中实现" class="headerlink" title="在python中实现"></a>在python中实现</h3><p>在Python中，可以使用标准库中的 <code>base64</code> 模块实现多种不同的 Base 编码。该模块支持以下几种 Base 编码格式：</p>
<ul>
<li>Base16（也称为 Hex 编码）：使用 16 个字符（0-9 和 A-F）表示二进制数据。</li>
<li>Base32：使用 32 个字符（A-Z 和 2-7）表示二进制数据。</li>
<li>Base64：使用 64 个字符（A-Z、a-z、0-9 和 + /）表示二进制数据。</li>
<li>Base85：使用 85 个字符表示二进制数据，每个字符可以表示 4 个字节。</li>
</ul>
<p>这些编码格式都是基于一组固定的字符集，将二进制数据转换为一串可打印的字符。这些编码格式在实际应用中有不同的优缺点，可以根据需要选择合适的编码格式。</p>
<p>在 <code>base64</code> 模块中，可以使用以下方法来进行不同的编码和解码操作：</p>
<ul>
<li><code>base64.b16encode()</code> 和 <code>base64.b16decode()</code>：用于 Base16 编码和解码。</li>
<li><code>base64.b32encode()</code> 和 <code>base64.b32decode()</code>：用于 Base32 编码和解码。</li>
<li><code>base64.b64encode()</code> 和 <code>base64.b64decode()</code>：用于 Base64 编码和解码。</li>
<li><code>base64.a85encode()</code> 和 <code>base64.a85decode()</code>：用于 Base85 编码和解码。</li>
</ul>
<p>这些方法接受 <strong>bytes 类型</strong>的数据作为输入，并返回 <strong>bytes 类型</strong>的编码结果。如果需要将编码结果转换为字符串类型，可以使用 <code>.decode()</code> 方法将 bytes 对象转换为字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#例子</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要编码的二进制数据</span></span><br><span class="line">data = <span class="string">&#x27;Hello, World!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用base64进行编码</span></span><br><span class="line">encoded_data = base64.b64encode(data)</span><br><span class="line"><span class="built_in">print</span>(encoded_data)  <span class="comment"># 输出 &#x27;SGVsbG8sIFdvcmxkIQ==\n&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用base64进行解码</span></span><br><span class="line">decoded_data = base64.b64decode(encoded_data)</span><br><span class="line"><span class="built_in">print</span>(decoded_data)  <span class="comment"># 输出 &#x27;Hello, World!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把编码结果转换为字符串类型</span></span><br><span class="line">b64_str = b64_data.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b64_str)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/04/07/Hello-World/</url>
    <content><![CDATA[<h1 id="未竟之旅"><a href="#未竟之旅" class="headerlink" title="未竟之旅"></a>未竟之旅</h1><p>记录一下第一篇文章</p>
<span id="more"></span>

<h2 id="从0开始的部落格搭建"><a href="#从0开始的部落格搭建" class="headerlink" title="从0开始的部落格搭建"></a>从0开始的部落格搭建</h2><p>呃呃，很难说这个部落格，目前也算是能用起来了（能跑就是win）。</p>
<p>说说搭建的历史吧，可能是因为懒（废话就是）本想着去年就搭起来的，但是去年自己啥也不懂（今年好像也是呜呜呜呜），瞎搞了一个服务器，但是弄了半天没弄出来，直接放弃。今年采用这个静态页面托管，上线效率确实快，弄了一两节课就好了。（然而diy弄了一天）</p>
<p>目前就是，摁，在这里分享自己的技术学习吧（虽然我很菜的），以后可能考虑上线别的东西，可能是一些生活记录啥的（先鸽吧，鼠鼠是没有线虫生活的）</p>
<p>瞎寄吧说了半天，希望这个博客能活得长一点，能多分享技术，暂定今年发表100篇技术博客捏~ (￣▽￣) ~*（虽然感觉会鸽，anyway，先把flag立在这了）</p>
<hr>
<h2 id="有关博客搭建的事项"><a href="#有关博客搭建的事项" class="headerlink" title="有关博客搭建的事项"></a>有关博客搭建的事项</h2><p>好吧进入正题，把这次搭建博客的一些经验感悟先记录在这，供自己和他人以后参考</p>
<h3 id="可能需要了解的前置知识"><a href="#可能需要了解的前置知识" class="headerlink" title="可能需要了解的前置知识"></a>可能需要了解的前置知识</h3><p>什么是网站和网页？什么是服务器和域名？什么是……</p>
<p>——互联网黑话初入门</p>
<h3 id="我的博客配置"><a href="#我的博客配置" class="headerlink" title="我的博客配置"></a>我的博客配置</h3><p>目前采用的是Hexo</p>
<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><h3 id="其他插件"><a href="#其他插件" class="headerlink" title="其他插件"></a>其他插件</h3><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3>]]></content>
      <categories>
        <category>freeTalk</category>
      </categories>
      <tags>
        <tag>talkingToMyself</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP代码审计学习笔记（施工中）</title>
    <url>/2023/05/10/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%96%BD%E5%B7%A5%E4%B8%AD%EF%BC%89/</url>
    <content><![CDATA[<p>一点PHPtricks，正在学习更新中</p>
<p>“PHP是世界上最好的语言” ^^</p>
<span id="more"></span>

<h1 id="PHP代码审计学习笔记（施工中）"><a href="#PHP代码审计学习笔记（施工中）" class="headerlink" title="PHP代码审计学习笔记（施工中）"></a>PHP代码审计学习笔记（施工中）</h1><h2 id="PHP弱类型比较"><a href="#PHP弱类型比较" class="headerlink" title="PHP弱类型比较"></a>PHP弱类型比较</h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>PHP是一门弱类型语言,这意味着同一变量可以在不同时间存放不同类型的数据。由于PHP的弱类型特征,在部分比较操作符（== 、&gt; 、&lt; 等）比较<strong>不同类型的数据</strong>时，会进行<strong>类型转换</strong>后再比较，这可能导致一些非预期的结果。</p>
<h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p><strong>一、字符串与整型比较</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;10&#x27;</span> == <span class="number">10</span>        <span class="comment">// true </span></span><br><span class="line"><span class="string">&#x27;10&#x27;</span> === <span class="number">10</span>       <span class="comment">// false</span></span><br><span class="line"><span class="string">&#x27;10foo&#x27;</span> &gt; <span class="number">5</span>        <span class="comment">// true </span></span><br></pre></td></tr></table></figure>

<p>在 == 比较时，字符串’10’会转换为整型10，所以相等。但 === 全等比较不会发生类型转换，所以不相等。<br>在 &gt; 比较时，’10foo’ 被解析为10，所以 ‘10foo’ &gt; 5返回true。</p>
<p><strong>二、空字符串与零比较</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="number">0</span>           <span class="comment">// true </span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> === <span class="number">0</span>          <span class="comment">// false </span></span><br></pre></td></tr></table></figure>

<p> 在 == 比较中，空字符串 ‘’ 被转换为0，所以相等。但 === 全等比较不转换类型,所以不相等。</p>
<p>注：<strong>0、[]、[0]、null</strong>和任意字符进行<strong>弱类型比较</strong>都相等</p>
<p><strong>三、空数组与零比较</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">[] == <span class="number">0</span>           <span class="comment">// true </span></span><br><span class="line">[] === <span class="number">0</span>          <span class="comment">// false </span></span><br></pre></td></tr></table></figure>

<p> [] 被转换为0进行 == 比较，所以相等。但===不会转换类型,所以不相等。</p>
<p><strong>四、空与 NULL 比较</strong> </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="literal">null</span>        <span class="comment">// true </span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> === <span class="literal">null</span>       <span class="comment">// false </span></span><br></pre></td></tr></table></figure>

<p> == 比较时，null被转换为 ‘’ ，所以相等。但===不会转换类型,所以不相等。</p>
<h3 id="常见的利用类型"><a href="#常见的利用类型" class="headerlink" title="常见的利用类型"></a>常见的利用类型</h3><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://flag0.com/2019/09/20/php%E5%BC%B1%E7%B1%BB%E5%9E%8B/">php弱类型、强类型总结 | flag0’s Blog</a></p>
<h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><h5 id="md5绕过的技巧"><a href="#md5绕过的技巧" class="headerlink" title="md5绕过的技巧"></a>md5绕过的技巧</h5><p><a href="https://cloud.tencent.com/developer/beta/article/2070130">关于md5的绕过技巧-腾讯云开发者社区-腾讯云</a></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$str1</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;str1&#x27;</span>];</span><br><span class="line"><span class="variable">$str2</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;str2&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">md5</span>(<span class="variable">$str1</span>) == <span class="title function_ invoke__">md5</span>(<span class="variable">$str2</span>))&#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&#x27;OK&#x27;</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//?str1 = s1885207154a&amp;str2 = s1091221200a</span></span><br></pre></td></tr></table></figure>

<p>注意到比较的时候是弱类型比较，所以……</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$str1</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;str1&#x27;</span>];</span><br><span class="line"><span class="variable">$str2</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;str2&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">md5</span>(<span class="variable">$str1</span>) === <span class="title function_ invoke__">md5</span>(<span class="variable">$str2</span>)) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&#x27;OK&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//?str1[]=1&amp;str2[]=2</span></span><br></pre></td></tr></table></figure>

<p>PHP自身的特性使得可以提交一个数组，而md5函数传入数组的返回值都是NULL，这样就可以绕过强类型比较了。所以这里用GET传入就行了</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$str1</span> = (<span class="keyword">string</span>)<span class="variable">$_GET</span>[<span class="string">&#x27;str1&#x27;</span>];</span><br><span class="line"><span class="variable">$str2</span> = (<span class="keyword">string</span>)<span class="variable">$_GET</span>[<span class="string">&#x27;str2&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">md5</span>(<span class="variable">$str1</span>) === <span class="title function_ invoke__">md5</span>(<span class="variable">$str2</span>)) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&#x27;OK&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于强制类型转换，所以不能传入数组了，这里就需要MD5碰撞：</p>
<p>一个关于md5碰撞功能的网页：<a href="https://www.win.tue.nl/hashclash/">HashClash</a></p>
<h5 id="其他例子："><a href="#其他例子：" class="headerlink" title="其他例子："></a>其他例子：</h5><p><strong>绕过is_numeric()函数：</strong></p>
<p>is_numeric()用于判断变量是否为数字，但是它实际检测的是<strong>变量是否可以转换为数字</strong>。所以:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">is_numeric</span>(<span class="string">&#x27;1foo&#x27;</span>)   <span class="comment">// true </span></span><br><span class="line"><span class="title function_ invoke__">is_numeric</span>(<span class="string">&#x27;foo1&#x27;</span>)   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>‘1foo’ 可以转换为1，所以返回true。攻击者可以通过构造类似 ‘1e10’ 来绕过is_numeric()检测。</p>
<p><strong>利用隐式类型转换绕过空验证：</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>] != <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Welcome <span class="subst">&#123;$_GET[&#x27;name&#x27;]&#125;</span>&quot;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码试图避免空字符串注入，但是攻击者可以发送name=0或name=1。因为PHP会将其隐式转换为字符串 ‘0’ 或 ‘1’ 。</p>
<p><strong>利用JSON绕过magic_quotes_gpc：</strong></p>
<p>PHP的魔术引号magic_quotes_gpc可以自动对POST、GET、COOKIE数据进行转义，来防范SQL注入。但是，当magic_quotes_gpc开启时，攻击者可以通过JSON数据绕过:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">POST: &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;xiaoming&#x27; OR 1=1 #&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$data</span> = <span class="title function_ invoke__">json_decode</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;data&#x27;</span>]);</span><br><span class="line"><span class="variable">$name</span> = <span class="variable">$data</span>-&gt;name;   <span class="comment">// $name = xiaoming&#x27; OR 1=1 #</span></span><br></pre></td></tr></table></figure>

<p>因为json_decode()会解析JSON并返回object，魔术引号不会对其转义。</p>
<p><strong>利用数组绕过stripslashes()：</strong></p>
<p>stripslashes()用于去除反斜杠转义，如果传入双引号字符串，它可以有效防止SQL注入。但是，攻击者可以通过数组绕过:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM users WHERE name = <span class="subst">&#123;$_GET[&#x27;name&#x27;]&#125;</span>&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">get_magic_quotes_gpc</span>()) &#123;</span><br><span class="line">    <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>] = <span class="title function_ invoke__">stripslashes</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>利用数组绕过preg_match()：</strong></p>
<p>preg_match()用于正则匹配，如果传入字符串会有效防止SQL注入。但是，攻击者可以发送数组绕过:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM users WHERE name = <span class="subst">&#123;$_GET[&#x27;name&#x27;]&#125;</span>&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/^[a-zA-Z0-9_]+$/&#x27;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>])) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>攻击者可以发送 GET 参数为 <code>name[]=1&#39;</code> ，产生 <code>$sql = &quot;SELECT * FROM users WHERE name = [1&#39;]&quot;</code> 成功绕过。</p>
<p><strong>利用对象绕过 stripslashes()：</strong></p>
<p>stripslashes()可以通过数组绕过，也可以通过对象绕过:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>] = <span class="title function_ invoke__">stripslashes</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line"><span class="variable">$name</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>攻击者可以构造:<code>POST: &#123;&quot;name&quot;: &#123;&quot;value&quot;: &quot;xiaoming&#39; OR 1=1 #&quot; &#125;&#125;</code></p>
<p>这会产生 <code>$name = &#123;&quot;value&quot;: &quot;xiaoming&#39; OR 1=1 # &quot;&#125;</code>，成功绕过stripslashes()。</p>
<p><strong>利用 JSON 绕过 mysql_real_escape_string()：</strong></p>
<p>和之前提到的利用JSON绕过magic_quotes_gpc类似，攻击者也可以利用JSON绕过mysql_real_escape_string():</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$name</span> = <span class="title function_ invoke__">mysql_real_escape_string</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM users WHERE name = &#x27;<span class="subst">$name</span>&#x27;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>攻击者发送<code>POST: &#123;&quot;name&quot;: &quot;xiaoming&#39; OR 1=1 # &quot;&#125; </code></p>
<p>这会产生 <code>$sql = &quot;SELECT * FROM users WHERE name = &#39;xiaoming\&#39; OR 1=1 # &#39;&quot;</code>，成功SQL注入。</p>
<p><strong>利用十六进制绕过preg_match()preg_match()：</strong></p>
<p>在匹配字符串时不会验证十六进制编码的数据，攻击者可以利用这点绕过：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/^[\da-z]+$/i&#x27;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;input&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM users WHERE name = <span class="subst">&#123;$_GET[&#x27;input&#x27;]&#125;</span>&quot;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>攻击者可以发送input=0x78，这会产生 <code>$sql = &quot;SELECT * FROM users WHERE name = 0x78&quot;</code> ，成功绕过正则匹配的验证。</p>
<p>其他更多姿势等待搜集整理，关键还是在弱类型比较中会产生<strong>类型转换</strong></p>
<h2 id="PHP代码注入"><a href="#PHP代码注入" class="headerlink" title="PHP代码注入"></a>PHP代码注入</h2><p>（目前没遇到太多，具体操作不是很清晰）</p>
<h3 id="简述："><a href="#简述：" class="headerlink" title="简述："></a>简述：</h3><p>PHP代码注入是一种代码执行漏洞，它允许攻击者向应用提交恶意代码，由应用执行。这通常是由于应用直接在PHP中执行<strong>用户提交的数据</strong>造成的。</p>
<h3 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h3><p>PHP代码注入的形成是因为PHP支持<strong>动态语句执行</strong>和<strong>变量解析替换</strong>。当用户输入的数据被直接用于动态构造语句时，攻击者可以通过特殊构造输入将其作为PHP代码执行，这就导致了代码注入。</p>
<h3 id="简单例子："><a href="#简单例子：" class="headerlink" title="简单例子："></a>简单例子：</h3><p><strong>获取系统信息</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$input</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;input&#x27;</span>];</span><br><span class="line">    <span class="keyword">eval</span>(<span class="variable">$input</span>);  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>访问:<code>?input=phpinfo();</code>这会执行phpinfo()函数显示PHP配置信息。</p>
<p><strong>读取敏感文件</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="variable">$file</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>访问:<code>?file=index.php</code>这会显示index.php文件的源代码。</p>
<p><strong>执行系统命令</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$cmd</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]; </span><br><span class="line">    <span class="title function_ invoke__">system</span>(<span class="variable">$cmd</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>访问:?cmd=whoami<br>这会执行whoami命令显示当前用户。</p>
<p>以上样例演示了php部分函数能直接执行提交的恶意数据，导致非预期的结果，实际中可能会有多种过滤和函数禁用，需要具体情况具体分析，查阅PHP手册进行绕过</p>
<h3 id="危险的函数："><a href="#危险的函数：" class="headerlink" title="危险的函数："></a>危险的函数：</h3><p>代码执行函数：eval()， assert(), </p>
<p>正则匹配函数：preg_replace(), </p>
<p>动态代码执行函数：create_function()，call_user_func()，call_user_func_array()。</p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://3wapp.github.io/WebSecurity/php_cmdinject.html">PHP代码执行与命令注入 · Wiki | janes</a></p>
<p><a href="http://www.beesfun.com/2017/04/18/PHP%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E5%92%8C%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/">PHP代码注入和命令注入 | bees’ blog</a></p>
<p><a href="https://blog.csdn.net/qq_41901122/article/details/104244366">PHP 代码注入知识点总结_if (isset(_星球守护者的博客-CSDN博客</a></p>
<p><a href="https://www.freebuf.com/column/166385.html">PHP代码命令注入小结 - FreeBuf网络安全行业门户</a></p>
<p>[<a href="https://www.cnblogs.com/jpSpaceX/articles/14900803.html">渗透测试]：PHP代码注入 - jpSpaceX - 博客园</a></p>
<h2 id="PHP伪协议"><a href="#PHP伪协议" class="headerlink" title="PHP伪协议"></a>PHP伪协议</h2><p>（感觉遇到了会用就行，前人已经总结得很完善了，就不再造轮子了）</p>
<p>简述：PHP伪协议是PHP代码中使用的特殊协议,它允许读取本地数据流、文件等资源。</p>
<p>利用方式：</p>
<p><a href="https://segmentfault.com/a/1190000018991087">PHP伪协议总结 - 个人文章 - SegmentFault 思否</a></p>
<p><a href="https://www.cnblogs.com/wjrblogs/p/12285202.html">CTF中常用的php伪协议利用 - 1ndex- - 博客园</a></p>
<p><a href="https://www.hetianlab.com/hetian/20210906145653">PHP伪协议的妙用 - 合天网安实验室</a></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2022-29221复现</title>
    <url>/2023/05/16/CVE-2022-29221%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<p>上周三WEB组的任务，白神真的会上压力，不过感觉复现一个CVE提升挺大的（特别是配环境环节，呵呵了），一下子弄懂了好多</p>
<span id="more"></span>

<h1 id="CVE-2022-29221复现"><a href="#CVE-2022-29221复现" class="headerlink" title="CVE-2022-29221复现"></a>CVE-2022-29221复现</h1><h2 id="漏洞概述："><a href="#漏洞概述：" class="headerlink" title="漏洞概述："></a>漏洞概述：</h2><blockquote>
<p>Smarty is a template engine for PHP, facilitating the separation of presentation (HTML/CSS) from application logic. Prior to versions 3.1.45 and 4.1.1, template authors could inject php code by choosing a malicious {block} name or {include} file name. Sites that cannot fully trust template authors should upgrade to versions 3.1.45 or 4.1.1 to receive a patch for this issue. There are currently no known workarounds.</p>
<p>Publish Date : 2022-05-24 Last Update Date : 2022-12-08</p>
<p><a href="https://www.cvedetails.com/cve/CVE-2022-29221/">CVE-2022-29221 : Smarty is a template engine for PHP, facilitating the separation of presentation (HTML/CSS) from application logic. Prio</a></p>
<p>翻译：Smarty是一个PHP模板引擎，它可以使显示层(HTML/CSS)和应用逻辑分离。在3.1.45和4.1.1版本之前，模板作者可以通过选择恶意的{block}name或{include}file来注入PHP代码。那些无法完全信任模板作者的网站应该升级到3.1.45或4.1.1版本，以获得此问题的补丁。目前没有已知的解决方法。</p>
</blockquote>
<p><strong>术语解析：</strong></p>
<ul>
<li>模板引擎：一种将数据和表现分离开来的机制，数据和逻辑被封装，而表现则由模板决定。</li>
<li>显示层：也可称表现层或表示层，是软件架构的最外层，负责与用户的交互和数据的可视化。</li>
<li>应用逻辑：也称业务逻辑，是软件开发中实现业务功能和处理业务流程的逻辑代码。</li>
<li>注入：在计算机安全中，注入通常是指恶意的、未经验证的数据被输入到解释器里，导致未预期的命令执行或者访问未授权的数据和程序。</li>
</ul>
<p><strong>漏洞类型：SSTI</strong></p>
<p>（什么是SSTI详情参考SSTI学习笔记）</p>
<h2 id="Smarty模板概述："><a href="#Smarty模板概述：" class="headerlink" title="Smarty模板概述："></a>Smarty模板概述：</h2><p>Smarty是一个主流的采用php编写的模板引擎。其目录文件结构应如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Smarty/</span><br><span class="line">|</span><br><span class="line">|--www.demo.com</span><br><span class="line">	|</span><br><span class="line">	|--cache/*			(缓存目录)</span><br><span class="line">	|--configs/			(设置目录)</span><br><span class="line">		|--test.conf	</span><br><span class="line">	|--plugins/*</span><br><span class="line">	|--templates_c/*		(编译目录)</span><br><span class="line">	|--templates/			(模板目录)</span><br><span class="line">		|--index.tpl</span><br><span class="line">	|--WWW				(页面根目录)</span><br><span class="line">		|--index.php	</span><br><span class="line">|--libs/				(库文件)</span><br><span class="line">	|</span><br><span class="line">	|--Smarty.class.php		(核心文件)</span><br><span class="line">    |--debug.tpl</span><br><span class="line">    |--sysplugins/*</span><br><span class="line">    |--plugins/*</span><br></pre></td></tr></table></figure>

<p>在配置好库文件后，就可以开始为你的网页使用Smarty了。</p>
<p>*官方说明</p>
<ul>
<li>Smarty可配置四个目录，默认名称分别是 <code>templates/</code>, <code>templates_c/</code>, <code>configs/</code> 和 <code>cache/</code>。</li>
<li>这些都分别对应Smarty类的属性定义 <a href="https://www.smarty.net/docs/zh_CN/variable.template.dir.tpl"><code>$template_dir</code></a>, <a href="https://www.smarty.net/docs/zh_CN/variable.compile.dir.tpl"><code>$compile_dir</code></a>, <a href="https://www.smarty.net/docs/zh_CN/variable.config.dir.tpl"><code>$config_dir</code></a>, 和 <a href="https://www.smarty.net/docs/zh_CN/variable.cache.dir.tpl"><code>$cache_dir</code></a>。</li>
<li>强烈建议分别在每个使用Smarty的程序中都单独定义这些目录。</li>
<li>你可以通过<a href="https://www.smarty.net/docs/zh_CN/api.test.install.tpl"><code>testInstall()</code></a> 来测试Smarty是否有权限读写这些目录。</li>
</ul>
<p>*其他</p>
<ul>
<li>模板目录(template dir)存放所有的模板文件，这是开发者编写和维护的目录。</li>
<li>编译目录(compile dir)在模板文件修改后，Smarty会自动重新编译模板，生成对应的PHP文件。</li>
<li>缓存目录(cache dir)存储渲染后的HTML内容。当模板或数据发生变化时，cache目录会被自动清空，forcing Smarty重新渲染所有模板。</li>
</ul>
<p>使用方式：</p>
<p>从github上下载Smarty源码，解压后文档目录为：</p>
<p><img src="/2023/05/16/CVE-2022-29221%E5%A4%8D%E7%8E%B0/.././CVE-2022-29221%E5%A4%8D%E7%8E%B0/image-20230516201359523.png" alt="image-20230516201359523"></p>
<p>关键是libs文件夹，储存着渲染的核心代码。</p>
<p>demo文件夹如图：</p>
<p><img src="/2023/05/16/CVE-2022-29221%E5%A4%8D%E7%8E%B0/.././CVE-2022-29221%E5%A4%8D%E7%8E%B0/image-20230516201436412.png" alt="image-20230516201436412"></p>
<p>为了使用Smarty模板，需要把libs文件夹复制到网站根目录中，然后在目录下建创两个文件夹：templates和templates_c即可。</p>
<p>PS.在使用前，请在本地开启php环境，我采用的是phpstudy</p>
<p>一个简单的使用示例：</p>
<p><img src="/2023/05/16/CVE-2022-29221%E5%A4%8D%E7%8E%B0/.././CVE-2022-29221%E5%A4%8D%E7%8E%B0/image-20230516140331370.png" alt="image-20230516140331370"></p>
<p>网页如图：</p>
<p><img src="/2023/05/16/CVE-2022-29221%E5%A4%8D%E7%8E%B0/.././CVE-2022-29221%E5%A4%8D%E7%8E%B0/image-20230516140346510.png" alt="image-20230516140346510"></p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>使用phpstudy搭建本地网站即可，再用phpstorm调试，调试的教程自行搜索</p>
<h3 id="演示-block"><a href="#演示-block" class="headerlink" title="演示{block}"></a>演示{block}</h3><p>在github下载poc：</p>
<p><a href="https://github.com/sbani/CVE-2022-29221-PoC">sbani/CVE-2022-29221-PoC: CVE-2022-29221 Proof of Concept Code - Smarty RCE</a></p>
<p>网页源码：</p>
<p><img src="/2023/05/16/CVE-2022-29221%E5%A4%8D%E7%8E%B0/.././CVE-2022-29221%E5%A4%8D%E7%8E%B0/image-20230516141935696.png" alt="image-20230516141935696"></p>
<p>打开网页看看效果：</p>
<p><img src="/2023/05/16/CVE-2022-29221%E5%A4%8D%E7%8E%B0/.././CVE-2022-29221%E5%A4%8D%E7%8E%B0/image-20230516142025190.png" alt="image-20230516142025190"></p>
<p>可以看到<code>system(whoami)</code>命令已经被执行了，包括后面的ABC字符。</p>
<p>也可以通过GET方法传递参数调用{block}块：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;../libs/Smarty.class.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$smarty</span> = <span class="keyword">new</span> <span class="title class_">Smarty</span>();</span><br><span class="line"><span class="variable">$smarty</span>-&gt;<span class="title function_ invoke__">setTemplateDir</span>(<span class="string">&#x27;./template&#x27;</span>);</span><br><span class="line"><span class="variable">$smarty</span>-&gt;<span class="title function_ invoke__">setConfigDir</span>(<span class="string">&#x27;/./config&#x27;</span>);</span><br><span class="line"><span class="variable">$smarty</span>-&gt;<span class="title function_ invoke__">setCompileDir</span>(<span class="string">&#x27;./compile&#x27;</span>);</span><br><span class="line"><span class="variable">$smarty</span>-&gt;<span class="title function_ invoke__">setCacheDir</span>(<span class="string">&#x27;./cache&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$template_string</span> = <span class="string">&quot;hello&quot;</span> . <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">    <span class="variable">$smarty</span>-&gt;<span class="title function_ invoke__">display</span>(<span class="string">&#x27;string:&#x27;</span> . <span class="variable">$template_string</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果GET参数name存在,就构造一个Smarty模板字符串,内容是hello加上name的值。</span></span><br><span class="line"><span class="comment">然后使用Smarty的display()方法输出这个构造的模板字符串。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="variable">$smarty</span>-&gt;<span class="title function_ invoke__">display</span>(<span class="string">&#x27;index.tpl&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>网页演示效果：</p>
<p><img src="/2023/05/16/CVE-2022-29221%E5%A4%8D%E7%8E%B0/.././CVE-2022-29221%E5%A4%8D%E7%8E%B0/image-20230516221502423.png" alt="image-20230516221502423"></p>
<h3 id="演示-include"><a href="#演示-include" class="headerlink" title="演示{include}"></a>演示{include}</h3><p>poc：<code>&#123;include file=&#39;string:*/include&quot;flag.txt&quot;;exit;/*&#39; inline=1&#125;</code></p>
<p>网站源码：</p>
<p><img src="/2023/05/16/CVE-2022-29221%E5%A4%8D%E7%8E%B0/.././CVE-2022-29221%E5%A4%8D%E7%8E%B0/image-20230516230614671.png" alt="image-20230516230614671"></p>
<p>网站结果：</p>
<p><img src="/2023/05/16/CVE-2022-29221%E5%A4%8D%E7%8E%B0/.././CVE-2022-29221%E5%A4%8D%E7%8E%B0/image-20230516230649975.png" alt="image-20230516230649975"></p>
<p>同样可以通过GET方法调用：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;../libs/Smarty.class.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$smarty</span> = <span class="keyword">new</span> <span class="title class_">Smarty</span>();</span><br><span class="line"><span class="variable">$smarty</span>-&gt;<span class="title function_ invoke__">setTemplateDir</span>(<span class="string">&#x27;./template&#x27;</span>);</span><br><span class="line"><span class="variable">$smarty</span>-&gt;<span class="title function_ invoke__">setConfigDir</span>(<span class="string">&#x27;/./config&#x27;</span>);</span><br><span class="line"><span class="variable">$smarty</span>-&gt;<span class="title function_ invoke__">setCompileDir</span>(<span class="string">&#x27;./compile&#x27;</span>);</span><br><span class="line"><span class="variable">$smarty</span>-&gt;<span class="title function_ invoke__">setCacheDir</span>(<span class="string">&#x27;./cache&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$template_string</span> = <span class="string">&quot;hello&quot;</span> . <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">    <span class="variable">$smarty</span>-&gt;<span class="title function_ invoke__">display</span>(<span class="string">&#x27;string:&#x27;</span> . <span class="variable">$template_string</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$smarty</span>-&gt;<span class="title function_ invoke__">display</span>(<span class="string">&#x27;index.tpl&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>结果如图：</p>
<p><img src="/2023/05/16/CVE-2022-29221%E5%A4%8D%E7%8E%B0/.././CVE-2022-29221%E5%A4%8D%E7%8E%B0/image-20230516230911960.png" alt="image-20230516230911960"></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>首先查看修复代码：</p>
<p><a href="https://github.com/smarty-php/smarty/commit/64ad6442ca1da31cefdab5c9874262b702cccddd">Merge branch ‘security/blockfunctioninjection’ · smarty-php/smarty@64ad644</a></p>
<p>在修复代码中，可以看到存在漏洞的都是系统插件文件：</p>
<p><img src="/2023/05/16/CVE-2022-29221%E5%A4%8D%E7%8E%B0/.././CVE-2022-29221%E5%A4%8D%E7%8E%B0/image-20230516192358926.png" alt="image-20230516192358926"></p>
<p><strong>补充：</strong></p>
<p>libs/sysplugins/目录存放了Smarty模板引擎的系统插件，以<code>libs/sysplugins/smarty_internal_compile_block.php</code>为例，它是Smarty模板引擎的系统插件文件之一。其主要作用是：解析模板中的块结构，生成PHP代码，实现块的覆盖、继承和输出功能。</p>
<h4 id="block-块"><a href="#block-块" class="headerlink" title="{block}块"></a>{block}块</h4><p>关键修改的部分：</p>
<p><img src="/2023/05/16/CVE-2022-29221%E5%A4%8D%E7%8E%B0/.././CVE-2022-29221%E5%A4%8D%E7%8E%B0/image-20230516142213673.png" alt="image-20230516142213673"></p>
<p><strong>Smarty模板中{block}块的作用：</strong><a href="https://www.smarty.net/docs/zh_CN/language.function.block.tpl">{block} | Smarty</a></p>
<p><code>&#123;block&#125;</code>可在模板上定义一块区域，以进行模板继承。子模板中的<code>&#123;block&#125;</code>区域代码，将会替换父模板对应的区域代码。</p>
<p>另外，<code>&#123;block&#125;</code>可以设置成合并父子模板的相应区域。在子模板的<code>&#123;block&#125;</code>中定义 <code>append</code> 或 <code>prepend</code>，可以使子模板附加在父模板 <code>&#123;block&#125;</code>区域的后面或前面。 在<code>&#123;block&#125;</code>内容中使用{$smarty.block.parent}，可以让父模板的区域代码放到 子模板<code>&#123;block&#125;</code>内的任何位置。</p>
<p><strong>具体过程：</strong></p>
<p>当Smarty编译模板文件时，遇到{block}标签，会调用<code>smarty_internal_compile_block.php</code>这个系统插件进行编译。该插件会执行以下操作：</p>
<ol>
<li><p>获取{block}标签的name属性，作为块名。</p>
</li>
<li><p>如果name属性为空，则使用块内的第一个文本作为name。</p>
</li>
<li><p>检查是否有同名的父级块，如果有，标记为块覆盖。</p>
</li>
<li><p><strong>生成块开始和结束的PHP代码</strong>，如：</p>
</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/* &#123;block name&#125; */</span></span><br><span class="line"><span class="comment">//块开始</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">/* &#123;/block&#125; */</span> </span><br><span class="line"><span class="comment">//块结束</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>如果标记为块覆盖，生成的PHP代码中会调用父级块。</li>
<li>递归编译块内的内容。 </li>
<li>如果块被留空，生成的PHP代码会直接调用父级块。</li>
</ol>
<p>回到{block}块出现的漏洞，未修复前，存在漏洞的代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$output</span> = <span class="string">&quot;&lt;?php\n&quot;</span>;</span><br><span class="line"><span class="variable">$output</span> .= <span class="string">&quot;/* &#123;block <span class="subst">&#123;$_name&#125;</span>&#125; */\n&quot;</span>;	<span class="comment">//这里是注入点</span></span><br><span class="line"><span class="variable">$output</span> .= <span class="string">&quot;class <span class="subst">&#123;$_className&#125;</span> extends Smarty_Internal_Block\n&quot;</span>;</span><br><span class="line"><span class="variable">$output</span> .= <span class="string">&quot;&#123;\n&quot;</span>;</span><br><span class="line">...<span class="comment">//后面是调用那个函数的内容</span></span><br></pre></td></tr></table></figure>

<p>我们来看看这段代码的结果如何，</p>
<p>先是一个简单的例子演示，假设模板文件中存在这样的代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;block name=&quot;parent&quot;&#125;</span><br><span class="line">   &#123;block name=&quot;child&quot;&#125;</span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span>&gt;</span>Child block<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   &#123;/block&#125;</span><br><span class="line">&#123;/block&#125; </span><br></pre></td></tr></table></figure>

<p>那么编译后生成的php代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/* &#123;block parent&#125; */</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent_child</span> <span class="keyword">extends</span> <span class="title">Smarty_Internal_Block</span></span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">callChild</span>(<span class="params"><span class="variable">$params</span>, <span class="variable">$content</span>, <span class="variable">$template</span>, &amp;<span class="variable">$repeat</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;p&gt;Child block&lt;/p&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* &#123;block child&#125; */</span></span><br><span class="line"><span class="variable language_">$this</span>-&gt;_tag_stack[] = <span class="keyword">array</span>(<span class="string">&#x27;parent_child&#x27;</span>, <span class="keyword">array</span>());</span><br><span class="line"><span class="comment">/* &#123;/block&#125; */</span></span><br><span class="line"><span class="title function_ invoke__">array_pop</span>(<span class="variable">$this</span>-&gt;_tag_stack);</span><br></pre></td></tr></table></figure>

<p>所以，如果给{block}块的“name”参数传入恶意代码，如本漏洞的poc：<code>&#123;block name=&quot;poc*/system(&#39;whoami&#39;)/*&quot;&#125;ABC&#123;/block&#125;</code>，就可以通过注释符把原本的代码注释掉，从而实现代码执行。</p>
<p>从poc来看（后面我改成phpinfo();来测试了，不影响结果）：</p>
<p><img src="/2023/05/16/CVE-2022-29221%E5%A4%8D%E7%8E%B0/.././CVE-2022-29221%E5%A4%8D%E7%8E%B0/image-20230516142253155.png" alt="image-20230516142253155"></p>
<p>注入后的结果为：</p>
<p><img src="/2023/05/16/CVE-2022-29221%E5%A4%8D%E7%8E%B0/.././CVE-2022-29221%E5%A4%8D%E7%8E%B0/image-20230516195835770.png" alt="image-20230516195835770"></p>
<p>可以看到，编译后的php文件已经实现想要的效果，所以最终合并后的php文件就会执行我们注入的代码，输出phpinfo()信息：</p>
<p><img src="/2023/05/16/CVE-2022-29221%E5%A4%8D%E7%8E%B0/.././CVE-2022-29221%E5%A4%8D%E7%8E%B0/image-20230516142839687.png" alt="image-20230516142839687"></p>
<h4 id="include-块"><a href="#include-块" class="headerlink" title="{include}块"></a>{include}块</h4><p>同样先查看修复代码：</p>
<p><img src="/2023/05/16/CVE-2022-29221%E5%A4%8D%E7%8E%B0/.././CVE-2022-29221%E5%A4%8D%E7%8E%B0/image-20230516230314831.png" alt="image-20230516230314831"></p>
<p>补充：<strong>smarty模板中{include}块的作用：</strong><a href="https://www.smarty.net/docs/zh_CN/language.function.include.tpl">{include} | Smarty</a></p>
<p><code>&#123;include&#125;</code>用于载入其他模板到当前模板中。 在包含模板中可用的变量，载入后在当前模板仍然可用。</p>
<p>它的基本语法是：<code>&#123;include file=&quot;模板文件名&quot;&#125;</code>或<code>&#123;include file=&quot;模板文件名&quot; 变量1=&quot;值1&quot; 变量2=&quot;值2&quot; ...&#125;</code>，</p>
<p>{include}块在Smarty模板中会被编译为函数调用，<strong>执行过程</strong>如下：</p>
<ol>
<li>解析指定模板，找到{include}块，获取file属性指定的模板文件名</li>
<li>加载被嵌入的模板文件，解析其内容</li>
<li><strong>将被嵌入模板的内容插入到{include}块所在位置</strong></li>
<li>如果{include}块传入了变量，则编译被嵌入模板期间，这些变量会作为本地变量使用</li>
<li>被嵌入模板编译完成后，本地变量消失,不影响外部模板</li>
</ol>
<p>一个简单的{include}块例子：</p>
<p>模板文件file1.tpl</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is file1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&#123;include file=&quot;file2.tpl&quot; content=&quot;Hello World!&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>模板文件file2.tpl</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is file2<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">&#123;$content&#125;</span><br></pre></td></tr></table></figure>

<p>编译过程：</p>
<ol>
<li>解析 file1.tpl ，找到 <code>&#123;include file=&quot;file2.tpl&quot; content=&quot;Hello World!&quot;&#125;</code></li>
<li>加载 file2.tpl ，并编译</li>
<li>file2.tpl 中，content 作为本地变量，值为 Hello World!</li>
<li>file2.tpl 编译结果 <code>&lt;p&gt;This is file2&lt;/p&gt;\n Hello World!</code>插入到 {include} 块位置</li>
<li>本地变量 content 消失，不影响 file1.tpl 中的其他变量</li>
</ol>
<p>所以file1.tpl编译后的结果是：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is file1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is file2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>了解了{include}块后，接着让我们来看看漏洞代码：</p>
<p>只看注入点的代码：<code>$compiled_code .= &quot;/* Start inline template \&quot;&#123;$sourceInfo&#125;\&quot; =============================*/\n&quot;;</code></p>
<p>这行代码的意思是：在<code>$compiled_code</code>变量中增加一段注释，表明接下来的是来自<code>&#123;sourceInfo&#125;</code>的内联模板代码。</p>
<p>举个例子：<br>如果<code>&#123;sourceInfo&#125;</code>的值是”test.tpl string:” ，那么这行代码会给添加这样的注释：</p>
<p><code>/* Start inline template &quot;test.tpl string:&quot; =============================*/</code></p>
<p>注释会在编译后的模板代码中，用于标示某段代码来自哪个模板文件或字符串。</p>
<p>编译后，一个可能的内容是：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Hello&quot;</span>;  </span><br><span class="line"><span class="meta">?&gt;</span>  </span><br><span class="line"><span class="comment">/* Start inline template &quot;test.tpl string:&quot; =============================*/</span>  </span><br><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot; World!&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>所以，和{block}块一样，存在可控参数利用注释达到代码执行的漏洞。</p>
<p>整段代码解释：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$compiled_code</span> = <span class="string">&quot;&lt;?php\n\n&quot;</span>;</span><br><span class="line"><span class="variable">$compiled_code</span> .= <span class="string">&quot;/* Start inline template \&quot;<span class="subst">&#123;$sourceInfo&#125;</span>\&quot; =============================*/\n&quot;</span>;	<span class="comment">//注释，标志模板代码开始</span></span><br><span class="line"><span class="variable">$compiled_code</span> .= <span class="string">&quot;function <span class="subst">&#123;$tpl-&gt;compiled-&gt;unifunc&#125;</span> (Smarty_Internal_Template \$_smarty_tpl) &#123;\n&quot;</span>;	<span class="comment">//编译模板函数</span></span><br><span class="line"><span class="variable">$compiled_code</span> .= <span class="string">&quot;?&gt;\n&quot;</span> . <span class="variable">$tpl</span>-&gt;compiler-&gt;<span class="title function_ invoke__">compileTemplateSource</span>(<span class="variable">$tpl</span>, <span class="literal">null</span>, <span class="variable">$compiler</span>-&gt;parent_compiler);	<span class="comment">//编译子模板</span></span><br><span class="line"><span class="variable">$compiled_code</span> .= <span class="string">&quot;&lt;?php\n&quot;</span>;</span><br><span class="line"><span class="variable">$compiled_code</span> .= <span class="string">&quot;&#125;\n?&gt;\n&quot;</span>;</span><br><span class="line"><span class="variable">$compiled_code</span> .= <span class="variable">$tpl</span>-&gt;compiler-&gt;<span class="title function_ invoke__">postFilter</span>(<span class="variable">$tpl</span>-&gt;compiler-&gt;blockOrFunctionCode);	<span class="comment">//一个过滤函数，没看懂在做啥</span></span><br><span class="line"><span class="variable">$compiled_code</span> .= <span class="string">&quot;&lt;?php\n\n&quot;</span>;</span><br><span class="line"><span class="variable">$compiled_code</span> .= <span class="string">&quot;/* End inline template \&quot;<span class="subst">&#123;$sourceInfo&#125;</span>\&quot; =============================*/\n&quot;</span>;<span class="comment">//模板代码结束</span></span><br><span class="line"><span class="variable">$compiled_code</span> .= <span class="string">&#x27;?&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">unset</span>(<span class="variable">$tpl</span>-&gt;compiler);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$tpl</span>-&gt;compiled-&gt;has_nocache_code) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>来看看调试结果：</p>
<p><img src="/2023/05/16/CVE-2022-29221%E5%A4%8D%E7%8E%B0/.././CVE-2022-29221%E5%A4%8D%E7%8E%B0/image-20230516235234835.png" alt="image-20230516235234835"></p>
<p>所以，原理和{block}块一样，都是因为恶意代码把原本的代码注释掉，导致恶意代码执行。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>以上未修复前的代码存在注入漏洞。深入思考一下：</p>
<p>回顾上文存在漏洞的第二句代码：<code>$output .= &quot;/* &#123;block &#123;$_name&#125;&#125; */\n&quot;;</code></p>
<p>这句代码的本意，是在Smarty编译后的PHP代码中，为模板块增加注释：<code>/* &#123;block &#123;$_name&#125;&#125; */</code></p>
<p>该注释主要目的是为了方便在调试或修改模板时，快速定位到模板中的功能块。在Smarty模板编译过程中，会为不同来源的代码添加不同的注释，这有利于我们调试和理解编译后产生的PHP代码。但是，这样实现的注释却有代码注入的风险。</p>
<p>实际上，一般情况下，在Smarty编译后的模板文件(templates_c/*.php)中的注释，默认不会出现在最终渲染的页面中。因为PHP在执行模板文件时，会自动忽略PHP注释，所以开发者就以为代码是安全的。但是，从上文可以看到，如果注入了恶意代码，则最终渲染出的模板还是会执行恶意代码。</p>
<p>查看修补后的代码：</p>
<p><code> $compiled_code .= $compiler-&gt;cStyleComment(&quot; Start inline template \&quot;&#123;$sourceInfo&#125;\&quot; =============================&quot;) . &quot;\n&quot;;</code></p>
<p><code> $output .= $compiler-&gt;cStyleComment(&quot; &#123;block &#123;$_name&#125;&#125; &quot;) . &quot;\n&quot;;</code></p>
<p>修复后采用cStyleComment()函数来生成C风格的注释，避免了直接在模板文件中使用<code>/*</code>和<code>*/</code>。可能是因为PHP本身就支持C风格注释，所以导致开发者偷懒（=.=），结果产生这样的漏洞，联想到Pink哥发现的那个小程序，也是开发者逻辑设置不当产生的。嗯哼……</p>
<hr>
<p>其他有的没的的补充：</p>
<p>Smarty模板渲染的完整过程主要分为以下几步:</p>
<ol>
<li><p>读取模板文件<br>通过<code>&#123;include file=&#39;xxx.tpl&#39;&#125;</code>或直接指定模板文件<code>$smarty-&gt;display(&#39;xxx.tpl&#39;)</code>读取模板内容。</p>
</li>
<li><p>编译模板<br> 将模板文件内容编译成PHP代码，输出到templates_c目录。如果模板未修改，则直接读取编译缓存。</p>
</li>
<li><p>执行编译结果<br>执行templates_c目录下的PHP文件，渲染模板逻辑与输出。</p>
</li>
<li><p>读取配置文件<br>Smarty会自动加载configs目录下的配置文件，设置全局变量、权限等。</p>
</li>
<li><p>缓存结果<br>Smarty默认会缓存模板渲染结果，输出到cache目录。如果模板或数据未修改，会直接输出缓存内容。</p>
</li>
<li><p>处理模板函数、变量、逻辑等<br>编译模板过程中，Smarty处理模板中用到的函数、变量、条件语句、循环等逻辑。</p>
</li>
<li><p>处理标签插件</p>
<p>Smarty使用标签插件扩展其功能，在渲染过程中加载并执行标签插件。</p>
</li>
<li><p>输出渲染结果<br>最终Smarty输出渲染好的HTML内容。</p>
</li>
</ol>
<p>其他补充：</p>
<p>使用Smarty模板获取参数内容的方式：</p>
<ol>
<li>获取SESSION参数</li>
</ol>
<p>使用<code>&#123;$smarty.session.name&#125;</code>获取SESSION中name的参数值。<br>例如,在PHP页面设置SESSION为:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;user&#x27;</span>] = <span class="string">&#x27;John&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>然后在模板中可以获取:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;$smarty.session.user&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">John</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>获取GET参数</li>
</ol>
<p>使用<code>&#123;$smarty.get.var&#125;</code>获取GET请求中的var参数值。<br>例如，页面URL是:</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">/index.php?name=Jack&amp;age=20</span><br></pre></td></tr></table></figure>

<p>在模板中:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;$smarty.get.name&#125;  &#123;$smarty.get.age&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jack 20</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>获取POST参数</li>
</ol>
<p>使用<code>&#123;$smarty.post.var&#125;</code>获取POST请求中的var参数值。<br>例如，在PHP页面获取POST数据:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$name</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;name&#x27;</span>]; </span><br><span class="line"><span class="variable">$age</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;age&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>在模板中:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;$smarty.post.name&#125;  &#123;$smarty.post.age&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jack 20 </span><br></pre></td></tr></table></figure>

<ol start="4">
<li>直接从$smarty变量获取 </li>
</ol>
<p>如果在PHP中有这样的赋值:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$smarty</span>-&gt;<span class="title function_ invoke__">assign</span>(<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;John&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>则在模板中可以通过<code>&#123;$user&#125;</code>直接获取:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;$user&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">John</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>VHDL介绍</title>
    <url>/2023/05/23/VHDL%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>小孩不懂事，写着玩的。</p>
<p>由于对数电课件极度不满意，简直依托，在瞎几把看几天祖传代码和文档后，写出来的。感觉缺点是少了一些简单的例子，但是也懒得搞了，实际上只要对着祖传代码看就行，哪一句不懂就翻翻，或者查查，很快就能明白。</p>
<span id="more"></span>

<h1 id="VHDL简单手册"><a href="#VHDL简单手册" class="headerlink" title="VHDL简单手册"></a>VHDL简单手册</h1><h2 id="0、介绍"><a href="#0、介绍" class="headerlink" title="0、介绍"></a>0、介绍</h2><p>什么是VHDL？</p>
<p>VHDL是一种硬件描述语言（Hardware Description Language），用于描述数字系统的结构和行为。它允许设计人员使用一种与传统编程语言相似的语法来描述数字系统。VHDL既可以算是一种编程语言，也可以算是一种硬件描述语言，但更倾向于<strong>硬件描述语言</strong>。</p>
<blockquote>
<p>从语法和结构上来说，VHDL确实像一种编程语言，它有变量、信号、过程、函数、包、类型等编程语言的要素。设计人员可以用类似编程的方式来描述硬件系统和行为。但是，VHDL的目的和功能与一般编程语言还是有本质差异的:</p>
<ol>
<li>VHDL的最终目标是生成物理的数字电路实现，而不是只在计算机上运行。</li>
<li>VHDL需要对时钟、同步复位等硬件相关的概念进行精确描述和处理。这需要硬件设计的思维方式和知识。</li>
<li>VHDL的执行模型是并行的，它定义了硬件中所有信号的并行变化方式。这与顺序执行的软件语言有本质区别。</li>
<li>VHDL是强类型语言，它严格限定了每条信号和变量的类型，以确保最终实现的电路稳定性和正确性。这种静态类型检查与软件语言也不同。</li>
</ol>
</blockquote>
<h2 id="1、VHDL语言结构"><a href="#1、VHDL语言结构" class="headerlink" title="1、VHDL语言结构"></a>1、VHDL语言结构</h2><p>（至少也得清楚它的结构吧）</p>
<h3 id="库（Library）："><a href="#库（Library）：" class="headerlink" title="库（Library）："></a><strong>库（Library）</strong>：</h3><p>存放<strong>已编译</strong>程序包和数据集合的地方，可以被调用。</p>
<p>代码格式：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">library</span> 库名;</span><br><span class="line"><span class="keyword">use</span> 库名中的逻辑体名;</span><br></pre></td></tr></table></figure>

<p>代码实例：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">library</span> ieee;                  <span class="comment">--打开ieee库</span></span><br><span class="line"><span class="keyword">use</span> ieee.std_logic_1164.<span class="keyword">all</span>;   <span class="comment">--加载ieee中std_logic_1164包内的所有内容</span></span><br></pre></td></tr></table></figure>

<p>库的种类</p>
<ul>
<li>STD 库 - VHDL 标准库</li>
<li>IEEE 库 - VHDL 标准库的扩展</li>
<li>WORK 库 - 用户自己的库</li>
</ul>
<h3 id="实体（Entity）："><a href="#实体（Entity）：" class="headerlink" title="实体（Entity）："></a><strong>实体（Entity）</strong>：</h3><p>VHDL设计的<strong>起点</strong>是实体，它描述了电路的<strong>接口</strong>和<strong>端口</strong>。实体定义了电路的<strong>输入</strong>、<strong>输出</strong>以及其他必要的模式信息。实体定义了系统的边界，而<strong>端口</strong>定义了系统与外界的连接方式。实体的电路意义相当于器件，在电路原理图上相当于元件符号，它是一个完整的、独立的语言模块，描述了接口信息。而接口相当于器件的外部引脚，它说明了外部引脚的工作方式。</p>
<p><strong>实体代码格式：</strong></p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">entity</span> 实体名 <span class="keyword">is</span></span><br><span class="line">	[类属参数说明]</span><br><span class="line">	[端口说明]</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">entity</span> 实体名;</span><br></pre></td></tr></table></figure>

<p><strong>端口格式：</strong></p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">port</span>(</span><br><span class="line">	端口名a1, ..., 端口名an : 方向 类型;</span><br><span class="line">	...</span><br><span class="line">	端口名x1, ..., 端口名xn : 方向 类型</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>端口方向：</strong></p>
<ul>
<li>in - 输入端口，此类型的信号不能被赋值</li>
<li>out - 输出端口</li>
<li>inout - 双向端口</li>
<li>buffer - 缓冲端口</li>
</ul>
<p>下面是一个实体的示例：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">entity</span> TestDemo <span class="keyword">is</span></span><br><span class="line">  <span class="keyword">port</span> ( </span><br><span class="line">    inputA : <span class="keyword">in</span> <span class="built_in">std_logic</span>;</span><br><span class="line">    inputB : <span class="keyword">in</span> <span class="built_in">std_logic</span>;</span><br><span class="line">    outputC : <span class="keyword">out</span> <span class="built_in">std_logic</span></span><br><span class="line">  );</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">entity</span> TestDemo;</span><br></pre></td></tr></table></figure>

<p>这段代码定义了一个 VHDL 实体（Entity）TestDemo，该实体有3个端口 (Port) 。它的作用是：根据输入信号 inputA 和 inputB ，产生输出信号 outputC 。</p>
<ol>
<li>inputA：输入端口，类型为 std_logic ，表示接收一个标准逻辑信号作为输入。</li>
<li>inputB ：输入端口，类型也为 std_logic ，表示另一个输入标准逻辑信号。</li>
<li>outputC ：输出端口，类型为 std_logic ，表示产生一个标准逻辑信号作为输出。</li>
<li>std_logic ：是 VHDL 的一个预定义类型，用于表示数字电路中的逻辑值，它可以取 ‘0’ , ‘1’ , ‘Z’ , ‘W’ 等值。</li>
<li>in 和 out ：表示输入还是输出。</li>
</ol>
<h3 id="架构（Architecture）："><a href="#架构（Architecture）：" class="headerlink" title="架构（Architecture）："></a><strong>架构（Architecture）</strong>：</h3><p>架构定义了电路的<strong>行为</strong>和<strong>内部结构</strong>。一个实体可以有一个或多个架构。架构通过<strong>组合逻辑</strong>和<strong>时序逻辑</strong>描述电路的功能。架构描述了元件内部的逻辑功能，在电路上相当于器件的内部电路结构。（ VHDL 语言编译出的程序可以视为是一个黑盒模型，对于外部，只看得到输入和输出，并不清楚其内部具体逻辑）</p>
<p>代码格式：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">architecture</span> 构造体名 <span class="keyword">of</span> 实体名 <span class="keyword">is</span></span><br><span class="line">	[说明语句]</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	[功能描述语句]</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">architecture</span> 构造体名;</span><br></pre></td></tr></table></figure>

<p>下面是一个架构的示例：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">architecture</span> test <span class="keyword">of</span> TestDemo <span class="keyword">is</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">process</span>(inputA, inputB)</span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">-- 组合逻辑</span></span><br><span class="line">    outputC &lt;= inputA <span class="keyword">and</span> inputB;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">process</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">architecture</span> test;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，架构名为 “test” ，使用 process 描述了组合逻辑。</p>
<p>每当输入端口 inputA 或 inputB 发生变化时，process 中的语句将执行，并将计算结果赋值给输出端口 outputC 。</p>
<p>对于一个 VHDL 程序来说，IEEE标准库说明，实体和架构是<strong>最基本</strong>的三个部分，其他的结构可以选用，但是这三个缺一不可。</p>
<p>下面是一个完整的包含库，实体和架构的示例：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">library</span> ieee;                  </span><br><span class="line"><span class="keyword">use</span> ieee.std_logic_1164.<span class="keyword">all</span>;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">entity</span> TestDemo <span class="keyword">is</span></span><br><span class="line">  <span class="keyword">port</span> ( </span><br><span class="line">    inputA : <span class="keyword">in</span> <span class="built_in">std_logic</span>;</span><br><span class="line">    inputB : <span class="keyword">in</span> <span class="built_in">std_logic</span>;</span><br><span class="line">    outputC : <span class="keyword">out</span> <span class="built_in">std_logic</span></span><br><span class="line">  );</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">entity</span> TestDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">architecture</span> test <span class="keyword">of</span> TestDemo <span class="keyword">is</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">process</span>(inputA, inputB)</span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">-- 组合逻辑</span></span><br><span class="line">    outputC &lt;= inputA <span class="keyword">and</span> inputB;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">process</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">architecture</span> test;</span><br></pre></td></tr></table></figure>

<p>注意：实体名和当前VHDL文件名要相同。</p>
<h3 id="进程（Process）："><a href="#进程（Process）：" class="headerlink" title="进程（Process）："></a>进程（Process）：</h3><p>进程语句结构包含着一些实体中部分逻辑行为的独立的顺序语句。进程是一个<strong>并发</strong>语句块（多个进程并发执行，单个进程内语句顺序执行），进程结构有一个敏感信号表，这是进程启动的标志。对于表中列出的任何信号的改变，都将启动、执行进程内相应的顺序语句。</p>
<p>代码格式：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">process</span> (sensitivity_list) <span class="comment">-- 指定触发条件的敏感信号列表，可以是输入信号、时钟信号或其他触发条件。</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  [进程内的语句和逻辑]</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">process</span>;</span><br></pre></td></tr></table></figure>

<p>进程块内部包含了一系列的语句和逻辑，用于描述电路的行为。这些语句可以是条件语句、赋值语句、循环语句等，用于实现所需的逻辑功能。在VHDL中，可以在一个架构中定义多个进程，以实现不同的逻辑行为。</p>
<p>架构与进程的示例：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">architecture</span> 构造体名 <span class="keyword">of</span> 实体名 <span class="keyword">is</span></span><br><span class="line">  [说明语句]</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">process</span> (sensitivity_list)</span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    [进程内的语句和逻辑]</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">process</span>;</span><br><span class="line">	[其他语句和逻辑]</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">architecture</span> 构造体名;</span><br></pre></td></tr></table></figure>

<p>一个简单的时序逻辑示例：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">architecture</span> test <span class="keyword">of</span> TestDemo <span class="keyword">is</span></span><br><span class="line">  <span class="keyword">signal</span> reg : <span class="built_in">std_logic</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">process</span>(CLK)</span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> rising_edge(CLK) <span class="keyword">then</span></span><br><span class="line">      <span class="comment">-- 时序逻辑</span></span><br><span class="line">      reg &lt;= inputA;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">process</span>;</span><br><span class="line">  outputY &lt;= reg;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">architecture</span> test;</span><br></pre></td></tr></table></figure>

<p>以上进程语句定义了一个进程块，它的触发条件是时钟信号 CLK 的上升沿（使用<code>rising_edge(CLK)</code>来检测，也可以是<code>CLK&#39;event and CLK = &#39;1&#39;</code>）。在时钟信号的上升沿到来时，进程内部的代码会执行。在这个例子中，输入信号 inputA 的值被存储到寄存器 reg 中。</p>
<p>进程块也可以用于实现组合逻辑：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">architecture</span> test <span class="keyword">of</span> TestDemo <span class="keyword">is</span></span><br><span class="line">  <span class="keyword">signal</span> outputY : <span class="built_in">std_logic</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">process</span>(inputA, inputB)</span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">-- 组合逻辑</span></span><br><span class="line">    <span class="keyword">if</span> inputA = <span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> inputB = <span class="string">&#x27;0&#x27;</span> <span class="keyword">then</span></span><br><span class="line">      outputY &lt;= <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      outputY &lt;= <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">process</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">architecture</span> test;</span><br></pre></td></tr></table></figure>

<p>以上进程语句定义了一个进程块，触发条件是输入信号 inputA 和 inputB 的变化。在进程块内部的代码中，使用逻辑表达式进行条件判断，并根据条件的结果进行赋值。根据输入信号的值，outputY 被赋予相应的值。</p>
<p>还有其他不需要了解但实际上有的：块语句（Block），子程序（Subprogram），函数（Function），过程（Procedure），程序包（Package），配置（Configuration）…</p>
<h2 id="2、语言要素"><a href="#2、语言要素" class="headerlink" title="2、语言要素"></a>2、语言要素</h2><h3 id="文字规则"><a href="#文字规则" class="headerlink" title="文字规则"></a>文字规则</h3><p>（不会用就看，都是常识）</p>
<p>数字类文字：</p>
<ul>
<li>整数</li>
<li>实数</li>
<li>基数表示法：n#n#n#n（基数#该数值下的数#十进制表示的指数）</li>
</ul>
<p>字符串类文字：</p>
<ul>
<li>字符：单引号</li>
<li>字符串：双引号，相当于一维数组</li>
</ul>
<p>标识符：包括26个大小写字母，数字0~9，下划线_。</p>
<ul>
<li>必须以英文字母开头</li>
<li>必须是单一下划线，且前后必须都有英文或数字</li>
<li><strong>不区分大小写</strong></li>
<li>…</li>
</ul>
<p>下标名：<code>标识符 (表达式)</code></p>
<p>端名：<code>标识符 (表达式 方向 表达式)</code></p>
<h3 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h3><p>（这个得看看）</p>
<h4 id="变量（Variable）："><a href="#变量（Variable）：" class="headerlink" title="变量（Variable）："></a><strong>变量（Variable）</strong>：</h4><ul>
<li>声明格式：</li>
</ul>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">variable</span> 变量名 : 数据类型 [取值范围] [:= 初始值];</span><br></pre></td></tr></table></figure>

<ul>
<li>用法：变量用于在<strong>过程内部</strong>声明，并且<strong>只能</strong>在过程内部使用。变量可以在过程中被赋值和修改，并且具有<strong>局部作用域</strong>。变量可以用于存储中间结果、计算值或者临时存储数据。</li>
<li>行为：变量的赋值操作是立即生效的，并且可以多次赋值和修改。变量的赋值操作是阻塞的，即变量的值在赋值语句结束之后立即更新。（阻塞赋值：立即赋予新值，直到下次赋值；无阻塞赋值：虽然被赋予新值，但是直到当前进程结束才更新）</li>
</ul>
<p>由于变量的局部作用特点，通常用于组合逻辑中的数据传输。</p>
<h4 id="常量（Constant）："><a href="#常量（Constant）：" class="headerlink" title="常量（Constant）："></a><strong>常量（Constant）</strong>：</h4><ul>
<li>声明格式：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">constant 常量名 : 数据类型 [:= 初始值];</span><br></pre></td></tr></table></figure>

<ul>
<li>用法：常量用于在架构内声明，并且在整个架构中可见。常量一旦被赋值，其值在整个模拟过程中保持不变。常量通常用于存储不可变的参数、常数或者具有全局意义的值。</li>
<li>行为：常量的赋值操作只会在模拟开始时执行一次，并且之后不可修改。常量的值在模拟过程中保持不变。</li>
</ul>
<h4 id="信号（Signal）："><a href="#信号（Signal）：" class="headerlink" title="信号（Signal）："></a><strong>信号（Signal）</strong>：</h4><ul>
<li>声明格式：</li>
</ul>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">signal</span> 信号名称 : 类型 [:= 初始值];</span><br></pre></td></tr></table></figure>

<ul>
<li><p>用法：信号用于在<strong>架构</strong>内声明，并且在整个架构中可见（相当于<strong>全局</strong>）。信号可以被赋值和读取，并且可以在不同的过程中传递和存储数据。信号可以用于在组合逻辑和时序逻辑之间传递信息，但由于信号的全局特点，通常用于<strong>时序逻辑</strong>的数据传输。</p>
</li>
<li><p>行为：信号的赋值操作可以是阻塞的（使用<code>&lt;=</code>赋值符号）或非阻塞的（使用<code>:=</code>赋值符号）。阻塞赋值的信号赋值操作会等待过程结束之后才更新值，而非阻塞赋值的信号赋值操作是立即生效的。</p>
</li>
<li><p>信号<strong>赋值</strong>符号为<code>&lt;=</code>，但是<strong>初始化</strong>符号是<code>:=</code></p>
</li>
</ul>
<p>一个简单的计数器例子，结合上述三种：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">entity</span> Example <span class="keyword">is</span></span><br><span class="line">  <span class="keyword">port</span> (</span><br><span class="line">    clk : <span class="keyword">in</span> <span class="built_in">std_logic</span>; <span class="comment">-- 时序信号</span></span><br><span class="line">    reset : <span class="keyword">in</span> <span class="built_in">std_logic</span>; <span class="comment">-- 异步复位信号</span></span><br><span class="line">    data_in : <span class="keyword">in</span> <span class="built_in">std_logic_vector</span>(<span class="number">7</span> <span class="keyword">downto</span> <span class="number">0</span>); <span class="comment">-- 八位数据输入</span></span><br><span class="line">    data_out : <span class="keyword">out</span> <span class="built_in">std_logic_vector</span>(<span class="number">7</span> <span class="keyword">downto</span> <span class="number">0</span>) <span class="comment">-- 八位数据输出</span></span><br><span class="line">  );</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">entity</span> Example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">architecture</span> test <span class="keyword">of</span> Example <span class="keyword">is</span></span><br><span class="line">  <span class="keyword">constant</span> MAX_COUNT : <span class="built_in">natural</span> := <span class="number">10</span>; <span class="comment">-- 最大计数值，用常量保存</span></span><br><span class="line">  <span class="keyword">signal</span> counter : <span class="built_in">natural</span> := <span class="number">0</span>; <span class="comment">-- 计数，用信号传递</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">process</span> (clk, reset)</span><br><span class="line">    <span class="keyword">variable</span> temp : <span class="built_in">std_logic_vector</span>(<span class="number">7</span> <span class="keyword">downto</span> <span class="number">0</span>); <span class="comment">-- temp变量，用于临时储存修改后的输入数据，再发给输出</span></span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> reset = <span class="string">&#x27;1&#x27;</span> <span class="keyword">then</span> <span class="comment">-- 复位信号有效，重置计数器，并将输出值设为0</span></span><br><span class="line">      counter &lt;= <span class="number">0</span>;</span><br><span class="line">      data_out &lt;= (<span class="keyword">others</span> =&gt; <span class="string">&#x27;0&#x27;</span>); <span class="comment">-- 将信号data_out的所有位清零，或者用to/downto来设为0</span></span><br><span class="line">    <span class="keyword">elsif</span> rising_edge(clk) <span class="keyword">then</span> <span class="comment">-- 上升沿，其描述也可以是：clk&#x27;event and clk = &#x27;1&#x27;</span></span><br><span class="line">      <span class="keyword">if</span> counter &lt; MAX_COUNT <span class="keyword">then</span></span><br><span class="line">        temp := data_in; <span class="comment">-- 将输入数据赋值给temp</span></span><br><span class="line">        temp(<span class="number">7</span>) := <span class="string">&#x27;1&#x27;</span>;  <span class="comment">-- temp最高位设置为高电平</span></span><br><span class="line">        data_out &lt;= temp;</span><br><span class="line">        counter &lt;= counter + <span class="number">1</span>;  <span class="comment">-- 修改信号的值</span></span><br><span class="line">      <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">process</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">architecture</span> test;</span><br></pre></td></tr></table></figure>

<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>（实际上应该进行基本数据类型，预定义数据类型的分类说明，但是很多用不到，只需要了解也许用到的就行）</p>
<ul>
<li>整数 integer<ul>
<li>范围-(2^31-1)到(2^31-1)</li>
<li>能够使用加减乘除运算</li>
</ul>
</li>
<li>位 bit<ul>
<li>取值’0’或’1’，使用单引号括起来</li>
<li>不等同与数字中的0或1，只是两种逻辑状态的取值，但可用于无符号的算术运算</li>
</ul>
</li>
<li>位矢量 bit_vector<ul>
<li>使用双引号括起来的一组值，如”000”</li>
<li>使用时先声明矢量长度，如<code>signal s : bit_vector(15 downto 0)</code></li>
</ul>
</li>
<li>布尔值 boolean<ul>
<li>取值 true 或 false</li>
<li>和 bit 不同，没有数值含义。不能进行算术运算，可以进行逻辑运算</li>
</ul>
</li>
<li>字符 character<ul>
<li>使用单引号括起来</li>
<li>区分字符 ’1’ 和位 ’1’ 时可以使用<code>character(&#39;1&#39;)</code></li>
</ul>
</li>
<li>字符串 string<ul>
<li>使用双引号括起来</li>
<li>常用于程序的提示和说明</li>
<li>需要说明长度，如<code>variable s : string(0 to 3)</code></li>
</ul>
</li>
</ul>
<p>需要了解的是<strong>自定义数据类型</strong></p>
<p>type语句用法：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> 数据类型名 <span class="keyword">is</span> 数据类型定义 <span class="keyword">of</span> 基本数据类型;</span><br><span class="line"> <span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">type</span> 数据类型名 <span class="keyword">is</span> 数据类型定义;</span><br></pre></td></tr></table></figure>

<p>数据类型名由设计者决定，数据类型定义指的是用来描述该类型的表达方式和表达内容，例如：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> stl <span class="keyword">is</span> <span class="keyword">array</span> (<span class="number">0</span> <span class="keyword">to</span> <span class="number">15</span>) <span class="keyword">of</span> <span class="built_in">std_logic</span>; <span class="comment">-- stl是一个具有16个元素的数组型数据类型，每一个元素都是std_logic型</span></span><br><span class="line"><span class="keyword">type</span> week <span class="keyword">is</span> (sum, mon, tue, wed, thu, fri, sat); <span class="comment">-- week所定义的是一组由文字表示的枚举类型，每一个文字都可代表具体数值，如sum = &#x27;0&#x27;，mon = &#x27;1&#x27;，tue = &#x27;10&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>枚举类型</strong></p>
<p>VHDL 中的枚举数据类型是一种特殊的数据类型，它们是用文字符号来表示一组实际的二进制数。例如：状态机的每一状态在实际电路中是以一组触发器的当前二进制数位的组合来表示的，但设计者在状态机的设计中，为了更利于阅读、编译和 VHDL 综合器的优化，往往将表征每一状态的二进制数组用文字符号来代表，即<strong>状态符号化</strong>。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> m_state <span class="keyword">is</span> (state1, state2, state3, state4, state5);</span><br><span class="line"><span class="keyword">signal</span> preState, nextState : m_state;</span><br></pre></td></tr></table></figure>

<p>当然枚举类型也可以直接用数值来定义，但必须使用单引号：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> my_logic <span class="keyword">is</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>, <span class="string">&#x27;W&#x27;</span>,<span class="string">&#x27;0&#x27;</span>); <span class="comment">-- Z，W是VHDL中特殊的状态量</span></span><br></pre></td></tr></table></figure>

<p>运算符没有太大区别。</p>
<h2 id="3、描述语句"><a href="#3、描述语句" class="headerlink" title="3、描述语句"></a>3、描述语句</h2><p><strong>综述：</strong></p>
<p>在 VHDL 中，一个进程是由一系列顺序语句构成的，而进程本身属并行语句。也就是说：在同一设计实体中，所有的进程是并行执行的。然而任一给定的时刻内，在每一个进程内只能执行一条顺序语句（基于行为仿真）。一个进程与其设计实体的其它部分进行数据交换的方式只能通过信号或端口。如果要在进程中完成某些特定的算法和逻辑操作，也可以通过依次调用子程序来实现，但子程序本身并无顺序和并行语句之分。</p>
<p>利用顺序语句可以描述逻辑系统中的组合逻辑、时序逻辑或它们的综合体。</p>
<h3 id="顺序语句："><a href="#顺序语句：" class="headerlink" title="顺序语句："></a>顺序语句：</h3><p>VHDL 有如下六类基本顺序语句：</p>
<h4 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h4><p>格式：</p>
<p><code>变量 := 数据;</code>  </p>
<p><code>信号 &lt;= 数据;</code></p>
<p>需要注意的是信号的赋值与初始化不同。</p>
<h5 id="赋值目标"><a href="#赋值目标" class="headerlink" title="赋值目标"></a>赋值目标</h5><p>赋值语句中的赋值目标有四种类型</p>
<ol>
<li><p>标识符赋值目标：和上面三种已经说过</p>
</li>
<li><p>数组单元素赋值目标：标识符(下标名) &lt;= 数据，例如：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SIGNAL</span> a : <span class="built_in">std_logic_vector</span> (<span class="number">0</span> <span class="keyword">to</span> <span class="number">3</span>);</span><br><span class="line">...</span><br><span class="line">a (<span class="number">0</span>) &lt;= <span class="number">1</span>;</span><br><span class="line">a (<span class="number">1</span>) &lt;= <span class="number">0</span>;</span><br><span class="line">a (<span class="number">2</span>) &lt;= <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>段下标元素赋值目标：标识符(下标名) &lt;= 数据，</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">variable</span> a : <span class="built_in">std_logic_vector</span>(<span class="number">1</span> <span class="keyword">to</span> <span class="number">4</span>);</span><br><span class="line">...</span><br><span class="line">a (<span class="number">1</span> <span class="keyword">to</span> <span class="number">2</span>) := <span class="string">&quot;10&quot;</span>;</span><br><span class="line">a (<span class="number">1</span> <span class="keyword">to</span> <span class="number">4</span>) := <span class="string">&quot;1011&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>不需要了解</p>
</li>
</ol>
<h4 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h4><p>流程控制语句一共有5种：</p>
<h5 id="IF-语句"><a href="#IF-语句" class="headerlink" title="IF 语句"></a>IF 语句</h5><p>IF 语句的语句结构有以下三种：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 第一种：</span></span><br><span class="line"><span class="keyword">if</span> 条件 <span class="keyword">then</span></span><br><span class="line">	顺序语句</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="comment">-- 第二种：</span></span><br><span class="line"><span class="keyword">if</span> 条件 <span class="keyword">then</span></span><br><span class="line">	顺序语句</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	顺序语句</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="comment">-- 第三种：</span></span><br><span class="line"><span class="keyword">if</span> 条件 <span class="keyword">then</span></span><br><span class="line">	顺序语句</span><br><span class="line"><span class="keyword">elsif</span> 条件 <span class="keyword">then</span></span><br><span class="line">	顺序语句</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	顺序语句</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br></pre></td></tr></table></figure>

<h5 id="CASE-语句"><a href="#CASE-语句" class="headerlink" title="CASE 语句"></a>CASE 语句</h5><figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> 表达式 <span class="keyword">is</span></span><br><span class="line">	<span class="keyword">when</span> value1 =&gt; 顺序语句;</span><br><span class="line">	<span class="keyword">when</span> value2 =&gt; 顺序语句;</span><br><span class="line">	<span class="keyword">when</span> <span class="keyword">others</span> =&gt; 顺序语句;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">case</span>;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>这里的<code>=&gt;</code>不是操作符，相当于 then</li>
</ul>
<h5 id="LOOP-语句"><a href="#LOOP-语句" class="headerlink" title="LOOP 语句"></a>LOOP 语句</h5><p>即循环语句</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 单个LOOP语句：</span></span><br><span class="line">[<span class="keyword">loop</span>标号:] <span class="keyword">loop</span></span><br><span class="line">	顺序语句</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">loop</span> [<span class="keyword">loop</span>标号];</span><br><span class="line"><span class="comment">-- 例如：</span></span><br><span class="line">L1 : <span class="keyword">loop</span></span><br><span class="line">    a := a+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">exit</span> L1 <span class="keyword">when</span> a &gt; <span class="number">10</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">loop</span> L1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- for_loop语句</span></span><br><span class="line">[<span class="keyword">loop</span>标号:] <span class="keyword">for</span> 循环变量 <span class="keyword">in</span> 循环范围次数 <span class="keyword">loop</span></span><br><span class="line">	顺序语句</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">loop</span> [<span class="keyword">loop</span>标号];</span><br><span class="line"><span class="comment">-- 例如：</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="number">0</span> <span class="keyword">to</span> <span class="number">3</span> <span class="keyword">loop</span></span><br><span class="line">    <span class="keyword">if</span> a &gt; <span class="number">4</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       a := a + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">loop</span>;</span><br></pre></td></tr></table></figure>

<h5 id="NEXT-语句"><a href="#NEXT-语句" class="headerlink" title="NEXT 语句"></a>NEXT 语句</h5><p>NEXT 语句主要用在 LOOP 语句执行中进行有条件的或无条件的转向控制。它的语句格式有以下三种：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 第一种：执行到next语句时，无条件终止本次循环，开始下一次循环</span></span><br><span class="line"><span class="keyword">next</span>;</span><br><span class="line"><span class="comment">-- 第二种：与第一种基本相同，适用于多重loop嵌套</span></span><br><span class="line"><span class="keyword">next</span> <span class="keyword">loop</span> 标号;</span><br><span class="line"><span class="comment">-- 第三种：条件跳转</span></span><br><span class="line"><span class="keyword">next</span> <span class="keyword">loop</span> 标号 <span class="keyword">when</span> 条件;</span><br></pre></td></tr></table></figure>

<h5 id="EXIT-语句"><a href="#EXIT-语句" class="headerlink" title="EXIT 语句"></a>EXIT 语句</h5><p>EXIT 语句与 NEXT 语句十分相似：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 第一种：执行到exit语句时，跳出循环</span></span><br><span class="line"><span class="keyword">exit</span>;</span><br><span class="line"><span class="comment">-- 第二种：与第一种基本相同，适用于多重loop嵌套</span></span><br><span class="line"><span class="keyword">exit</span> <span class="keyword">loop</span> 标号;</span><br><span class="line"><span class="comment">-- 第三种：条件跳出</span></span><br><span class="line"><span class="keyword">exit</span> <span class="keyword">loop</span> 标号 <span class="keyword">when</span> 条件;</span><br></pre></td></tr></table></figure>

<h5 id="WHIT-语句"><a href="#WHIT-语句" class="headerlink" title="WHIT 语句"></a>WHIT 语句</h5><p>在进程中（包括过程中）当执行到 WAIT 等待语句时，运行程序将被挂起（Suspension），直到满足此语句设置的结束挂起条件后，将重新开始执行进程或过程中的程序。对于不同的结束挂起条件的设置， WAIT 语句有以下四种不同的语句格式：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wait</span>; <span class="comment">-- 永远挂起</span></span><br><span class="line"><span class="keyword">wait</span> <span class="keyword">on</span> 信号; <span class="comment">-- 敏感信号等待语句，信号变化时，结束挂起</span></span><br><span class="line"><span class="keyword">wait</span> <span class="keyword">until</span> 条件; <span class="comment">-- 条件等待语句，条件中信号变化且满足条件时，结束挂起</span></span><br><span class="line"><span class="keyword">wait</span> <span class="keyword">for</span> 时间表达式; <span class="comment">-- 超时等待语句，无要求</span></span><br></pre></td></tr></table></figure>

<p>子程序调用语句（无要求）</p>
<h5 id="RETURN-语句"><a href="#RETURN-语句" class="headerlink" title="RETURN 语句"></a>RETURN 语句</h5><figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span>; <span class="comment">-- 结束过程</span></span><br><span class="line"><span class="keyword">return</span> 表达式; <span class="comment">-- 结束函数，且返回一个值</span></span><br></pre></td></tr></table></figure>

<h5 id="NULL-语句"><a href="#NULL-语句" class="headerlink" title="NULL 语句"></a>NULL 语句</h5><p>不执行任何操作，唯一功能式使逻辑流程进入下一步。常用于case语句中的多余操作</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<h4 id="其他语句说明"><a href="#其他语句说明" class="headerlink" title="其他语句说明"></a>其他语句说明</h4><h5 id="属性（ATTRIBUTE）描述与定义语句"><a href="#属性（ATTRIBUTE）描述与定义语句" class="headerlink" title="属性（ATTRIBUTE）描述与定义语句"></a>属性（ATTRIBUTE）描述与定义语句</h5><p>属性可以用于获取对象的特定信息、配置对象的行为、进行代码优化或进行仿真控制。VHDL 中的属性由预定义属性和用户自定义属性两种类型。VHDL 中预定义属性描述语句有许多应用，可用于对信号或其它项目的多种属性检测或统计。可具有属性的项目：</p>
<ul>
<li>类型、子类型</li>
<li>过程、函数</li>
<li>信号、变量、常量</li>
<li>实体、结构体、配置</li>
<li>元件</li>
<li>语句标号</li>
</ul>
<h5 id="预定义属性（Predefined-Attributes）："><a href="#预定义属性（Predefined-Attributes）：" class="headerlink" title="预定义属性（Predefined Attributes）："></a>预定义属性（Predefined Attributes）：</h5><ul>
<li><p>预定义属性是 VHDL 语言提供的一组内置属性，用于获取对象的特定信息或配置对象的行为。</p>
</li>
<li><p>预定义属性以<code>&#39;</code>（单引号）开头，后面跟着属性名称和括号中的参数（如果有）。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">属性对象&#x27; 属性标识符</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="信号类属性："><a href="#信号类属性：" class="headerlink" title="信号类属性："></a>信号类属性：</h6><p>信号类中，最常用的是 event 。例如：<code>clock&#39;event</code>表示对以clock为标识符的信号，在一个极小的时间段内发生的事件（即电平变化）进行检测。<code>clock&#39;event and clock = &#39;1&#39;</code>就表示对clock上升沿信号进行检测</p>
<p>（以下的[(n)]均表示如果是二维数组的情况下，是二维数组的哪一行，如果不是自动忽略）</p>
<h6 id="数据区间类属性"><a href="#数据区间类属性" class="headerlink" title="数据区间类属性"></a>数据区间类属性</h6><p>主要有 range[(n)] 和 reverse_range[(n)] ，分别表示返回指定顺序/逆序范围。</p>
<p>例如：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">signal</span> range1 : <span class="keyword">in</span> <span class="built_in">std_logic_vector</span> (<span class="number">0</span> <span class="keyword">to</span> <span class="number">7</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range1<span class="symbol">&#x27;range</span> <span class="keyword">loop</span> <span class="comment">-- 等效于for i in 0 to 7 loop</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h6 id="数值类属性："><a href="#数值类属性：" class="headerlink" title="数值类属性："></a>数值类属性：</h6><p>主要有：left[(n)] 、right[(n)] 、high[(n)] 、low[(n)] 。</p>
<ul>
<li>left ：返回类型的左边界，</li>
<li>right ：返回类型的右边界</li>
<li>high ：返回类型的上限值</li>
<li>low ：返回类型的下限值</li>
</ul>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">process</span> (clk, a, b);</span><br><span class="line"><span class="keyword">type</span> obj <span class="keyword">is</span> <span class="keyword">array</span> (<span class="number">0</span> <span class="keyword">to</span> <span class="number">15</span>) <span class="keyword">of</span> <span class="built_in">bit</span>;</span><br><span class="line"><span class="keyword">signal</span> e1, e2, e3, e4;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	e1 &lt;= obj<span class="symbol">&#x27;right</span>; <span class="comment">-- 15</span></span><br><span class="line">	e2 &lt;= obj<span class="symbol">&#x27;left</span>; <span class="comment">-- 0</span></span><br><span class="line">	e3 &lt;= obj<span class="symbol">&#x27;high</span>; <span class="comment">-- 15</span></span><br><span class="line">	e4 &lt;= obj<span class="symbol">&#x27;low</span>; <span class="comment">-- 0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h6 id="数组类属性："><a href="#数组类属性：" class="headerlink" title="数组类属性："></a>数组类属性：</h6><p>length[(n)] 返回数组范围的总长度</p>
<h5 id="用户自定义属性"><a href="#用户自定义属性" class="headerlink" title="用户自定义属性"></a>用户自定义属性</h5><p>格式如下：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">attribute</span> 属性名 : 数据类型;</span><br><span class="line"><span class="keyword">attribute</span> 属性名 <span class="keyword">of</span> 对象名 : 对象类型 <span class="keyword">is</span> 值;</span><br></pre></td></tr></table></figure>

<h3 id="并行语句"><a href="#并行语句" class="headerlink" title="并行语句"></a>并行语句</h3><p>（看看就好，了解赋值就行，其他没必要深究，硬件真复杂）</p>
<p><strong>综述：</strong></p>
<p>并行语句结构是最具硬件描述语言特色的语句。各种并行语句在结构体中的执行是同步进行的（或者说是并行运行的）其执行方式与书写的顺序无关。在执行中，并行语句之间可以有信息往来，也可以是互为独立、互不相关、异步运行的（如多时钟情况）每一并行语句内部的语句运行方式可以有两种不同的方式，即并行执行方式（如块语句）和顺序执行方式（如进程语句）。</p>
<p>并行语句与顺序语句并不是相互对立的，它们往往相互包含，是一 个矛盾的统一体。严格地说 VHDL 中不存在纯粹的并行行为和顺序行为。例如：相对于其它的并行语句，进程属于并行语句，而进程内部运行的都是顺序语句。而一个单句并行赋值语句，从表面上看是一条完整的并行语句，但实质上却是一条进程语句的缩影，它完全可以用一条相同功能的进程来替代。所不同的是，进程中必须列出所有的敏感信号，而单纯的并行赋值语句的敏感信号是隐性列出的，而且即使是进程内部的顺序语句，也并非如人们想象的那样，每一条语句的运行都如同软件指令那样按时钟节拍来逐条运行的。</p>
<p>并行语句在架构中的使用格式：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">architecture</span> 架构名 <span class="keyword">of</span> 实体名 <span class="keyword">is</span></span><br><span class="line">    说明语句</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        并行语句</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">architecture</span> 架构名</span><br></pre></td></tr></table></figure>

<p>其实从模拟仿真的角度来说，对并行语句的考量没那么大，很多类型的语句不要求掌握，</p>
<h4 id="并行信号赋值语句"><a href="#并行信号赋值语句" class="headerlink" title="并行信号赋值语句"></a>并行信号赋值语句</h4><h5 id="简单信号赋值"><a href="#简单信号赋值" class="headerlink" title="简单信号赋值"></a>简单信号赋值</h5><p>并行简单信号赋值语句是 VHDL 并行语句结构的最基本的单元，它的语句格式如下：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">aim &lt;= expression</span><br></pre></td></tr></table></figure>

<h5 id="条件信号赋值语句"><a href="#条件信号赋值语句" class="headerlink" title="条件信号赋值语句"></a>条件信号赋值语句</h5><figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">aim &lt;= expression1 <span class="keyword">when</span> value1 <span class="keyword">else</span></span><br><span class="line">       expression2 <span class="keyword">when</span> value2 <span class="keyword">else</span></span><br><span class="line">       expression3;    </span><br></pre></td></tr></table></figure>

<h5 id="选择信号赋值"><a href="#选择信号赋值" class="headerlink" title="选择信号赋值"></a>选择信号赋值</h5><figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> 选择表达式 <span class="keyword">select</span> </span><br><span class="line">    aim &lt;= expression1 <span class="keyword">when</span> value1,</span><br><span class="line">		   expression2 <span class="keyword">when</span> value2,</span><br><span class="line">		   expression3 <span class="keyword">when</span> <span class="keyword">others</span>;</span><br></pre></td></tr></table></figure>

<h2 id="4、VHDL描述风格"><a href="#4、VHDL描述风格" class="headerlink" title="4、VHDL描述风格"></a>4、VHDL描述风格</h2><p>综述：</p>
<p>VHDL 的架构具体描述整个实体的逻辑功能，对于相同的电路功能，在架构中可以用不同的语句类型和描述方法来表达。主要有三种：行为描述，RTL 描述（数据流描述）和结构描述。其中RTL指的是寄存器传输语言。</p>
<h3 id="行为描述"><a href="#行为描述" class="headerlink" title="行为描述"></a>行为描述</h3><p>如果 VHDL 的架构只描述了电路的功能或者行为，没有指明实现这些行为的硬件结构，则称为行为描述。其特点是</p>
<ul>
<li>只描述输出与输入间转换的行为，不包含任何结构信息</li>
<li>主要用顺序语句描述，即含有进程的非结构化逻辑。</li>
</ul>
<blockquote>
<p>VHDL 的行为描述功能确实具有很独特之处和很大的优越性。在应用 VHDL 进行系统设计时，行为描述方式是最重要的逻辑描述方式 ，行为描述方式是 VHDL 编程的核心，可以说，没有行为描述就没有 VHDL 。正因为这样，有人把 VHDL 称为行为描述语言。因此，只有 VHDL 作为硬件电路的行为描述语言，才能满足自顶向下设计流程的要求，从而成为电子线路系统级仿真和设计的最佳选择 。相比之下 Verilog-HDL 只能属于 RTL 级硬件描述语言。</p>
</blockquote>
<p>剩余两种不需要了解，现在只用得到行为描述。</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://discretetom.github.io/academic/VHDL/vhdl/#vhdl%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">VHDL硬件描述语言 - DiscreteTom’s Blog</a></p>
<p>[1] 潘松 王国栋.VHDL实用教程[M].四川：电子科技大学出版社，1999年.</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/04/06/index/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>一些杂项</title>
    <url>/2023/04/19/%E4%B8%80%E4%BA%9B%E6%9D%82%E9%A1%B9/</url>
    <content><![CDATA[<p> 一些无意发现的东西</p>
<span id="more"></span>

<h2 id="设计心理学？"><a href="#设计心理学？" class="headerlink" title="设计心理学？"></a>设计心理学？</h2><p>哥们以前任务栏图标</p>
<p><img src="/2023/04/19/%E4%B8%80%E4%BA%9B%E6%9D%82%E9%A1%B9/.././%E4%B8%80%E4%BA%9B%E6%9D%82%E9%A1%B9/image-20230419000435176.png" alt="image-20230419000435176"></p>
<p>这样经常会点错，想选择谷歌浏览器会点到edge</p>
<p>然后这样改了</p>
<p><img src="/2023/04/19/%E4%B8%80%E4%BA%9B%E6%9D%82%E9%A1%B9/.././%E4%B8%80%E4%BA%9B%E6%9D%82%E9%A1%B9/image-20230419000518990.png" alt="image-20230419000518990"></p>
<p>欸，莫名其妙就不会误触了！</p>
<p>嗯，可见分隔不同属性的优点</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2>]]></content>
      <categories>
        <category>development</category>
      </categories>
  </entry>
  <entry>
    <title>一些稀奇古怪的问题的记录与解决</title>
    <url>/2023/04/17/%E4%B8%80%E4%BA%9B%E7%A8%80%E5%A5%87%E5%8F%A4%E6%80%AA%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95%E4%B8%8E%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>如题所示，希望这些debug过程能提供一些参考，或者是自己以后忘了回来看看</p>
<span id="more"></span>

<h1 id="一些稀奇古怪的问题的记录和解决"><a href="#一些稀奇古怪的问题的记录和解决" class="headerlink" title="一些稀奇古怪的问题的记录和解决"></a>一些稀奇古怪的问题的记录和解决</h1><h2 id="chrome复制链接无法复制标题"><a href="#chrome复制链接无法复制标题" class="headerlink" title="chrome复制链接无法复制标题"></a>chrome复制链接无法复制标题</h2><p><strong>问题背景：</strong>经常在写文档或者查找资料的时候需要搜索网页，搜索完之后需要保存下来，但是chrome复制网页链接无法做到连同标题一起复制，导致回顾的时候常常不记得这个链接的大概内容，有时候一个临时文本框存了很多链接，自己看的也懵。使用edge后发现edge可以做到，就想着chrome也一定可以。</p>
<p><strong>解决方案：</strong>谷歌插件市场下载tapcopy插件，这款插件可以实现复制链接携带标题的功能，还可以自行选择格式，例如适用于md，html，js等等，甚至可以自定义格式</p>
<p><img src="/2023/04/17/%E4%B8%80%E4%BA%9B%E7%A8%80%E5%A5%87%E5%8F%A4%E6%80%AA%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95%E4%B8%8E%E8%A7%A3%E5%86%B3/.././%E4%B8%80%E4%BA%9B%E7%A8%80%E5%A5%87%E5%8F%A4%E6%80%AA%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95%E4%B8%8E%E8%A7%A3%E5%86%B3/image-20230417150612785.png" alt="image-20230417150612785"></p>
<p><img src="/2023/04/17/%E4%B8%80%E4%BA%9B%E7%A8%80%E5%A5%87%E5%8F%A4%E6%80%AA%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95%E4%B8%8E%E8%A7%A3%E5%86%B3/.././%E4%B8%80%E4%BA%9B%E7%A8%80%E5%A5%87%E5%8F%A4%E6%80%AA%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95%E4%B8%8E%E8%A7%A3%E5%86%B3/image-20230417150645544.png" alt="image-20230417150645544"></p>
]]></content>
      <categories>
        <category>development</category>
      </categories>
      <tags>
        <tag>deBug</tag>
      </tags>
  </entry>
  <entry>
    <title>数字电路复习</title>
    <url>/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p>考试周到了，快死掉了，赶紧复习。（因为还不习惯latex的语法，所以有些内容放不上来，只能文字叙述）</p>
<p>总结一下数电要考的重点内容还有注意事项？应该是，具体的题目参看课本例题和课后作业。</p>
<span id="more"></span>

<h1 id="数字电路复习"><a href="#数字电路复习" class="headerlink" title="数字电路复习"></a>数字电路复习</h1><h2 id="第一章——数字电路基础（ez，了解即可）"><a href="#第一章——数字电路基础（ez，了解即可）" class="headerlink" title="第一章——数字电路基础（ez，了解即可）"></a>第一章——数字电路基础（ez，了解即可）</h2><h3 id="数制转换（会用，能算）"><a href="#数制转换（会用，能算）" class="headerlink" title="数制转换（会用，能算）"></a>数制转换（会用，能算）</h3><p>进位计数制</p>
<p>2进制与10进制（整数和小数）的相互转换——<strong>除k求余法</strong>和<strong>乘k取整法</strong></p>
<p>2进制与8、16进制的相互转换</p>
<h3 id="常用编码（了解即可）"><a href="#常用编码（了解即可）" class="headerlink" title="常用编码（了解即可）"></a>常用编码（了解即可）</h3><h4 id="BCD码（会考BCD码之间和二进制数的转换）"><a href="#BCD码（会考BCD码之间和二进制数的转换）" class="headerlink" title="BCD码（会考BCD码之间和二进制数的转换）"></a>BCD码（会考BCD码之间和二进制数的转换）</h4><p>8421码，2421码（一般不考，因为有多种实现方式），余3码（8421码+3，即0011）</p>
<h4 id="机器码（以前的试卷出现过，了解即可）"><a href="#机器码（以前的试卷出现过，了解即可）" class="headerlink" title="机器码（以前的试卷出现过，了解即可）"></a>机器码（以前的试卷出现过，了解即可）</h4><p>原码：正数符号位为0，等于真值；负数符号位为1，等于真值。</p>
<p>反码：正数与原码相同；负数为原码取反。</p>
<p>补码：正数与原码相同；负数为反码加1。</p>
<h4 id="可靠性编码（在组合逻辑电路可能会让实现功能或者作为结果分析，了解逻辑表达式即可）"><a href="#可靠性编码（在组合逻辑电路可能会让实现功能或者作为结果分析，了解逻辑表达式即可）" class="headerlink" title="可靠性编码（在组合逻辑电路可能会让实现功能或者作为结果分析，了解逻辑表达式即可）"></a>可靠性编码（在组合逻辑电路可能会让实现功能或者作为结果分析，了解逻辑表达式即可）</h4><h5 id="奇偶检验码："><a href="#奇偶检验码：" class="headerlink" title="奇偶检验码："></a>奇偶检验码：</h5><p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412204828101.png" alt="image-20230412204828101"></p>
<p>ps.奇校验可以通过最后XOR1实现</p>
<p>奇偶校验码基本原理：</p>
<ul>
<li>奇数个1，它的和数总是1</li>
<li>偶数个1，它的和数总是0</li>
</ul>
<h5 id="格雷码："><a href="#格雷码：" class="headerlink" title="格雷码："></a>格雷码：</h5><p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412205038008.png" alt="image-20230412205038008"></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412205029561.png" alt="image-20230412205029561"></p>
<h4 id="字符编码：基本不考"><a href="#字符编码：基本不考" class="headerlink" title="字符编码：基本不考"></a>字符编码：基本不考</h4><h2 id="第二章——逻辑代数（主要是逻辑表达式的化简和卡诺图的化简，其他零碎的知识点知道就好）"><a href="#第二章——逻辑代数（主要是逻辑表达式的化简和卡诺图的化简，其他零碎的知识点知道就好）" class="headerlink" title="第二章——逻辑代数（主要是逻辑表达式的化简和卡诺图的化简，其他零碎的知识点知道就好）"></a>第二章——逻辑代数（主要是逻辑表达式的化简和卡诺图的化简，其他零碎的知识点知道就好）</h2><h3 id="逻辑代数基本定理和规则（了解即可，熟悉黑体部分）"><a href="#逻辑代数基本定理和规则（了解即可，熟悉黑体部分）" class="headerlink" title="逻辑代数基本定理和规则（了解即可，熟悉黑体部分）"></a>逻辑代数基本定理和规则（了解即可，熟悉黑体部分）</h3><p><strong>基本知识</strong>：逻辑代数的概念；五大公理（交换、结合、分配、0-1、互补）；与、或、非三种基本运算；逻辑函数的概念及定理；3大规则（代入、<strong>反演</strong>、<strong>对偶</strong>）；复合逻辑（与非、或非、与或非、<strong>异或</strong>、同或）；逻辑表达式的形式（与-或项，或-与项；最小项，最大项）</p>
<p>以上内容除了加粗部分得知道是怎么回事，其他的了解即可。</p>
<p><strong>逻辑函数的表示方法及其转换</strong></p>
<ul>
<li>逻辑表达式</li>
<li>真值表</li>
<li><strong>卡诺图</strong></li>
<li>电路图</li>
</ul>
<p><strong>异或</strong></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412210627259.png" alt="image-20230412210627259"></p>
<p><strong>逻辑函数的标准形式</strong>（这两个内容挺无语的，有时候会考到，了解就好）</p>
<p>最小项性质</p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412210810400-1681304891735-1.png" alt="image-20230412210810400"></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412210850120.png" alt="image-20230412210850120"></p>
<p>最大项性质</p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412210914704.png" alt="image-20230412210914704"></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412210956430.png" alt="image-20230412210956430"></p>
<p>最小项和最大项的关系：</p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412211036934.png" alt="image-20230412211036934"></p>
<h3 id="逻辑函数的化简"><a href="#逻辑函数的化简" class="headerlink" title="逻辑函数的化简"></a>逻辑函数的化简</h3><h4 id="代数化简法（掌握好代数化简法就可以解决考试和作业中出现的化简题目了）"><a href="#代数化简法（掌握好代数化简法就可以解决考试和作业中出现的化简题目了）" class="headerlink" title="代数化简法（掌握好代数化简法就可以解决考试和作业中出现的化简题目了）"></a>代数化简法（掌握好代数化简法就可以解决考试和作业中出现的化简题目了）</h4><ul>
<li>并项法</li>
<li>吸收法</li>
<li>消去法</li>
<li>配项法</li>
</ul>
<h4 id="卡诺图化简法（这个要熟练，因为后面逻辑电路也会用到卡诺图）"><a href="#卡诺图化简法（这个要熟练，因为后面逻辑电路也会用到卡诺图）" class="headerlink" title="卡诺图化简法（这个要熟练，因为后面逻辑电路也会用到卡诺图）"></a>卡诺图化简法（这个要熟练，因为后面逻辑电路也会用到卡诺图）</h4><p>卡诺图的画法</p>
<p>卡诺图的化简</p>
<p>约束项</p>
<h2 id="第三章——组合逻辑电路分析和设计（主要是中型组合逻辑元件，还有设计题）"><a href="#第三章——组合逻辑电路分析和设计（主要是中型组合逻辑元件，还有设计题）" class="headerlink" title="第三章——组合逻辑电路分析和设计（主要是中型组合逻辑元件，还有设计题）"></a>第三章——组合逻辑电路分析和设计（主要是中型组合逻辑元件，还有设计题）</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>了解基本逻辑门电路</p>
<p><strong>分析的基本步骤</strong></p>
<ol>
<li>明确<strong>输入输出</strong></li>
<li>根据电路<strong>写出逻辑表达式</strong></li>
<li>根据卡诺图<strong>化简</strong>，写出真值表</li>
<li>根据真值表<strong>判断功能</strong></li>
</ol>
<p><strong>逻辑函数形式的变换</strong>（以与或项为例，或与项求两次对偶即可，不重要，了解即可）</p>
<ul>
<li>与非门实现：两次求反，一次展开</li>
<li>或非门实现：一次对偶，两次求反，再次对偶</li>
<li>与或非门实现：两次求反</li>
</ul>
<p><strong>设计组合逻辑电路</strong>（会有大题）</p>
<ul>
<li>设置逻辑变量，明确<strong>输入输出</strong></li>
<li>根据功能列出<strong>真值表</strong></li>
<li>根据真值表得到<strong>逻辑表达式</strong>（也有的可以直接得到），再<strong>化简</strong>为最简逻辑表达式（若有无关项，可以借助化简）</li>
<li>根据化简结果选择<strong>要求的逻辑门</strong>实现</li>
</ul>
<p>这个没啥好说的，建议是看一些课本例题和往年例题，熟悉几道即可。</p>
<p>一般能列出真值表后面的就ez了，</p>
<h3 id="竞争与险象（了解，会判断即可）"><a href="#竞争与险象（了解，会判断即可）" class="headerlink" title="竞争与险象（了解，会判断即可）"></a>竞争与险象（了解，会判断即可）</h3><p><strong>判断险象</strong></p>
<p>有无<strong>同时</strong>出现原变量与反变量</p>
<ul>
<li>或形式：0型险象（因为原变量和反变量相或本该是1，但是由于延迟导致为0）</li>
<li>与形式：1型险象（因为原变量和反变量相与本该是0，但是由于延迟导致为1）</li>
</ul>
<p>卡诺圈<strong>相切</strong>法（看ppt一看就会）</p>
<p><strong>险象的消除</strong></p>
<ol>
<li>增加冗余项<ol>
<li>代数定理增加</li>
<li>卡诺圈增加使其不相切</li>
</ol>
</li>
<li>加选通脉冲</li>
<li>接滤波电容</li>
</ol>
<h3 id="中规模组合逻辑器件"><a href="#中规模组合逻辑器件" class="headerlink" title="中规模组合逻辑器件"></a>中规模组合逻辑器件</h3><p><strong>注意：</strong></p>
<ul>
<li>一般会考<strong>看图写话</strong>，给你一个已经拼好的器件，让你写出表达式，真值表，判断功能等，这种得熟悉元件的<strong>器件图</strong>（重点是数据选择器），<strong>功能表</strong>，<strong>逻辑表达式</strong></li>
<li>注意各种器件的<strong>拓展</strong>，能使端的使用</li>
<li>全加器，全减器需要知道电路图和逻辑表达式（最好能一眼出），可能会直接拿来做分析题</li>
<li>比较器需要熟悉逻辑表达式，可能会直接拿来做分析题</li>
<li>若要求用加法器实现，注意找输入与输出的数值关系</li>
</ul>
<h4 id="数据选择器（熟练）"><a href="#数据选择器（熟练）" class="headerlink" title="数据选择器（熟练）"></a>数据选择器（熟练）</h4><p><strong>元件图、功能表、逻辑表达式</strong>（这张图忽略了能使端）</p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230413221709919.png" alt="image-20230413221709919"></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412214151845.png" alt="image-20230412214151845"></p>
<p><strong>拓展</strong></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230413221840644.png" alt="image-20230413221840644"></p>
<p>（这个思路二没见考过，没时间建议直接跳过，资料上有）</p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230413222022810.png" alt="image-20230413222022810"></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230413222055918.png" alt="image-20230413222055918"></p>
<p><strong>应用：实现逻辑函数（只要能化成最小项，就能实现逻辑函数，又所有的表达式都能化为最小项，所以数据选择器能实现所有的逻辑函数）</strong></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412214312410.png" alt="image-20230412214312410"></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412214326048.png" alt="image-20230412214326048"></p>
<h4 id="译码器"><a href="#译码器" class="headerlink" title="译码器"></a>译码器</h4><h5 id="二进制译码器（关键是表达式）"><a href="#二进制译码器（关键是表达式）" class="headerlink" title="二进制译码器（关键是表达式）"></a>二进制译码器（关键是表达式）</h5><p><strong>元件图、功能表、逻辑表达式</strong></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230413223328019.png" alt="image-20230413223328019"></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230413222702360.png" alt="image-20230413222702360"></p>
<p><strong>拓展</strong></p>
<p>只需要将<strong>能使端用非门连接</strong>即可</p>
<p><strong>应用</strong>（待填坑）</p>
<h5 id="2-10进制译码器（简单了解即可）"><a href="#2-10进制译码器（简单了解即可）" class="headerlink" title="2-10进制译码器（简单了解即可）"></a>2-10进制译码器（简单了解即可）</h5><p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230413230235962.png" alt="image-20230413230235962"></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230413230300881.png" alt="image-20230413230300881"></p>
<h5 id="7段显示译码器（期中考了）"><a href="#7段显示译码器（期中考了）" class="headerlink" title="7段显示译码器（期中考了）"></a>7段显示译码器（期中考了）</h5><p>由<strong>译码器</strong>+<strong>显示器组成</strong></p>
<p>元件图、功能表</p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/681397236753.jpg" alt="681397236753"></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230413224114448.png" alt="image-20230413224114448"></p>
<p>其他说明：（结合上图的理解）</p>
<ul>
<li>灯测试输入LT非：检验其能否正常发光，为0时，a~g全为1，显示8，为0时，不影响，因此正常工作时应设为0</li>
<li>灭零输入RBI非（上图消隐段）：目的是不让显示的0熄灭，当其为0，且当A3A2A1A0=0000时，则灭灯</li>
<li>灭灯输入BI非：只要其为0，不论输入，都熄灭，因此正常工作时应设为1</li>
<li>灭零输出RBO非：只有A3A2A1A0=0000，且灭零输入RBI非=0时，才给出低电平输出，因此当其输出为0时，表示本该显示的0熄灭了</li>
</ul>
<h4 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h4><p>普通编码器元件图和优先编码器基本相同，但是同一时刻只允许一个信号输入。</p>
<h5 id="优先编码器（考过拓展）"><a href="#优先编码器（考过拓展）" class="headerlink" title="优先编码器（考过拓展）"></a>优先编码器（考过拓展）</h5><p>优先编码器为低电平有效，同一时刻允许多个输入，但是高位优先。</p>
<p>注意<strong>优先编码</strong>的含义，有时设计题会考到优先编码的题。</p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412214738799.png" alt="image-20230412214738799"></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230413235341831.png" alt="image-20230413235341831"></p>
<p>逻辑表达式就是A，B，C对应的为1的输入相或。</p>
<p>其他：</p>
<p>从真值表可以看出</p>
<ul>
<li>Is非选通端意为<strong>电路开关</strong>：当其为1时，输出被锁定，所有输入都无效，只有为0时才工作</li>
<li>Os选通端意为<strong>信号有效开关</strong>：当Is非为0时，电路开始工作，但若无有效的信号（即全部为1）此时输出虽然为111，但是Os为0，表示输出的是无效信号，即<strong>电路工作，但无有效编码输入</strong>。</li>
<li>Oex意为<strong>功能有效开关</strong>：当Is非为0，Os为1时，Oex为0，表示<strong>电路工作，且有有效编码输入</strong></li>
</ul>
<p><strong>拓展</strong>（待填坑）</p>
<p>两片8-3编码器拓展成一片16-4编码器</p>
<p>解释：</p>
<h4 id="分配器（和选择器相反）"><a href="#分配器（和选择器相反）" class="headerlink" title="分配器（和选择器相反）"></a>分配器（和选择器相反）</h4><p>元件图反过来，表达式和选择器相同，功能表相似。会选择器就会分配器。</p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230414002346610.png" alt="image-20230414002346610"></p>
<h4 id="加法器"><a href="#加法器" class="headerlink" title="加法器"></a>加法器</h4><h5 id="串行进位加法器（注意逻辑表达式即可）"><a href="#串行进位加法器（注意逻辑表达式即可）" class="headerlink" title="串行进位加法器（注意逻辑表达式即可）"></a>串行进位加法器（注意逻辑表达式即可）</h5><p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230414003049711.png" alt="image-20230414003049711"></p>
<p><strong>应用：</strong>（没时间就不看，这里不重要！）</p>
<p><strong>实现减法器和加法器</strong></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230414003955720.png" alt="image-20230414003955720"></p>
<p>M为控制信号，当M为0时，为加法器，当M为1时，为减法器。</p>
<p><strong>8421转换为余3码：</strong></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230414005127923.png" alt="image-20230414005127923"></p>
<h5 id="超前进位加法器（没见考过）"><a href="#超前进位加法器（没见考过）" class="headerlink" title="超前进位加法器（没见考过）"></a>超前进位加法器（没见考过）</h5><h4 id="比较器（考过输出表达式）"><a href="#比较器（考过输出表达式）" class="headerlink" title="比较器（考过输出表达式）"></a>比较器（考过输出表达式）</h4><h5 id="一位同比较器"><a href="#一位同比较器" class="headerlink" title="一位同比较器"></a>一位同比较器</h5><p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230414004512690.png" alt="image-20230414004512690"></p>
<p>多位的话用或非门连接各个部分即可</p>
<h5 id="多位数大小比较器（单位比较器可以通过多位实现，只使多位比较器的i-1判等位有效即可）"><a href="#多位数大小比较器（单位比较器可以通过多位实现，只使多位比较器的i-1判等位有效即可）" class="headerlink" title="多位数大小比较器（单位比较器可以通过多位实现，只使多位比较器的i-1判等位有效即可）"></a>多位数大小比较器（单位比较器可以通过多位实现，只使多位比较器的i-1判等位有效即可）</h5><p>一位：（只看逻辑符号和表达式就行！！）</p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230414004640857.png" alt="image-20230414004640857"></p>
<p>多位：</p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412215310620.png" alt="image-20230412215310620"></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230414003801308.png" alt="image-20230414003801308"></p>
<p><strong>拓展</strong></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230414003726239.png" alt="image-20230414003726239"></p>
<h2 id="第四章——触发器"><a href="#第四章——触发器" class="headerlink" title="第四章——触发器"></a>第四章——触发器</h2><p><strong>重点是触发器的功能，触发状态，转移方程</strong></p>
<p>结构和原理了解即可，不了解也无关紧要，<strong>看得懂输入输出</strong>即可</p>
<h3 id="基本RS触发器"><a href="#基本RS触发器" class="headerlink" title="基本RS触发器"></a>基本RS触发器</h3><p><strong>结构和原理：</strong></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412212216821.png" alt="image-20230412212216821"></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412212324383.png" alt="image-20230412212324383"></p>
<p><strong>逻辑功能描述</strong></p>
<ul>
<li>真值表（功能表）</li>
<li>状态转移表</li>
<li>状态方程</li>
<li>状态转移图</li>
<li>波形图</li>
</ul>
<h3 id="钟控触发器"><a href="#钟控触发器" class="headerlink" title="钟控触发器"></a>钟控触发器</h3><p>CP控制信号：CP=0，维持；CP=1，启动（高电平触发）</p>
<p>关键是记住<strong>状态转移方程</strong>，特别是<strong>JK触发器</strong>，其他的都比较ez</p>
<p><strong>钟控RS</strong></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412212620179.png" alt="image-20230412212620179"></p>
<p><strong>钟控D</strong></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412212730789.png" alt="image-20230412212730789"></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412212743286.png" alt="image-20230412212743286"></p>
<p><strong>钟控T</strong></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412212925780.png" alt="image-20230412212925780"></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412212939584.png" alt="image-20230412212939584"></p>
<p><strong>钟控JK</strong></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412212847601.png" alt="image-20230412212847601"></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412212905635.png" alt="image-20230412212905635"></p>
<p><strong>触发器的触发方式</strong></p>
<p>电平触发方式</p>
<p>边沿触发方式</p>
<h3 id="边沿触发器（和主从JK一起记，因为主从JK基本不用了）"><a href="#边沿触发器（和主从JK一起记，因为主从JK基本不用了）" class="headerlink" title="边沿触发器（和主从JK一起记，因为主从JK基本不用了）"></a>边沿触发器（和主从JK一起记，因为主从JK基本不用了）</h3><p>异步信号（以下仅列出功能，注意是低电平还是高电平）</p>
<p>Rd有效：置0</p>
<p>Sd有效：置1</p>
<p><strong>边沿JK触发器</strong></p>
<p>注意：</p>
<ul>
<li>主从JK触发器的一次翻转：如果在<strong>CP为1期间</strong>，<strong>JK信号发生改变</strong>，由于主触发器无法改变，所以当下降沿到来之时，输出信号会根据主触发器的信号而改变。但是边沿JK触发器不会有这种现象</li>
<li>考试的时候会把输出端接到JK端等等<strong>乱飞线操作</strong>，但一般都会给初始状态，记住状态转移方程或者记住J置1，K置0，异步信号优先，<strong>细心判断</strong>即可</li>
</ul>
<p><strong>维持阻塞D触发器</strong></p>
<p>可以进行分频</p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412213130328.png" alt="image-20230412213130328"></p>
]]></content>
      <categories>
        <category>inClassLearning</category>
      </categories>
      <tags>
        <tag>Digital circuits</tag>
      </tags>
  </entry>
</search>
