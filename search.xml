<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CTF中常见的编码方式和加密方法（正在施工中）</title>
    <url>/2023/05/01/CTF%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F%E5%92%8C%E5%8A%A0%E5%AF%86%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>一些基础知识，了解即可</p>
<span id="more"></span>

<h1 id="CTF常见的加密方式与编码方法总结（正在施工中）"><a href="#CTF常见的加密方式与编码方法总结（正在施工中）" class="headerlink" title="CTF常见的加密方式与编码方法总结（正在施工中）"></a>CTF常见的加密方式与编码方法总结（正在施工中）</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="2、4、8、16进制（自己了解下吧，感觉这块中学基础应该有）"><a href="#2、4、8、16进制（自己了解下吧，感觉这块中学基础应该有）" class="headerlink" title="2、4、8、16进制（自己了解下吧，感觉这块中学基础应该有）"></a>2、4、8、16进制（自己了解下吧，感觉这块中学基础应该有）</h3><h3 id="计算机内部处理数字的方式"><a href="#计算机内部处理数字的方式" class="headerlink" title="计算机内部处理数字的方式"></a>计算机内部处理数字的方式</h3><p><a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/computercode.html">原码, 反码, 补码 详解 - ziqiu.zhang - 博客园</a></p>
<h3 id="字符集和字符编码"><a href="#字符集和字符编码" class="headerlink" title="字符集和字符编码"></a>字符集和字符编码</h3><p>字符集和字符编码是计算机科学中的两个相关概念，它们通常一起使用来表示和处理文本数据。</p>
<p><strong>字符集</strong>是一组预定义的<strong>字符</strong>，每个字符都有一个唯一的标识符。例如，ASCII字符集定义了128个字符，包括字母、数字、标点符号和控制字符等。Unicode字符集则定义了超过100,000个字符，包括世界上大多数语言的字母、符号和表情符号等。</p>
<p><strong>字符编码</strong>是将字符集中的每个字符转换为计算机能够处理的数字编码的<strong>过程</strong>。计算机只能处理二进制数字，因此需要将字符集中的字符转换为二进制数字才能存储和处理。例如，ASCII编码将每个字符映射到一个7位的二进制数，范围从0到127。Unicode编码则使用不同的方案，其中UTF-8编码是最常用的一种方式。UTF-8编码使用1到4个字节来表示Unicode字符，这使得它可以支持超过1百万种字符。</p>
<p>可以这么理解，字符集是一个集合，字符编码是把字符对应到二进制数的一个映射。字符集定义了可用的字符集合，而字符编码定义了如何将这些字符转换为计算机能够处理的数字编码。</p>
<p>在实际应用中，字符集和字符编码往往被视为一个整体，通常使用术语“字符编码”来指代它们的组合。</p>
<h3 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h3><p><a href="https://zh.wikipedia.org/wiki/ASCII">ASCII - 维基百科，自由的百科全书</a></p>
<h2 id="Base编码"><a href="#Base编码" class="headerlink" title="Base编码"></a>Base编码</h2><h3 id="Base编码的历史"><a href="#Base编码的历史" class="headerlink" title="Base编码的历史"></a>Base编码的历史</h3><p><a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc4648.txt.pdf">Enscript Output (rfc-editor.org)</a></p>
<p>Base编码是一种<strong>将二进制数据转换为文本形式的编码方式</strong>，最初用于电子邮件传输。因为之前的电子邮件系统当初是为了传输 7 位 ASCII 文本而设计的，只能传输文本数据，不能传输二进制数据，此外不同邮件网关会对接收到的信息进行不同处理，就会导致信息不完整等问题。</p>
<p>因此，需要一种方法将二进制数据转换为文本数据，以便能够通过邮件系统进行传输。</p>
<p>在1973年，Robert J. Haskins开发了一种基于64个字符的编码方式，称为Radix-64编码。这种编码方式使用了26个大写字母、26个小写字母、10个数字和2个特殊符号（+和/），共计64个字符。Radix-64编码将3个8位的二进制数据块转换为4个6位的字符，因此<strong>可以将任意二进制数据编码为可打印的ASCII字符</strong>。Radix-64编码在后来的邮件系统中得到了广泛应用，成为了电子邮件传输中的标准编码方式。</p>
<p>在1990年代，Base编码成为了因特网传输中的常用编码方式之一。Base64编码是Radix-64编码的一种变种，它将3个8位的二进制数据块转换为4个6位的字符，使用的字符集为A-Z、a-z、0-9和两个特殊符号（+和/）。Base64编码在Web应用中得到广泛应用，例如将图片和其他二进制数据嵌入HTML代码中进行传输。</p>
<p>除了Base64编码外，还有许多其他的Base编码方式，例如Base16、Base32等。这些编码方式使用的字符集和编码算法都不同，但它们的基本原理相同，即将<strong>二进制数据转换为文本数据</strong>以便进行传输。</p>
<h3 id="Base编码的原理"><a href="#Base编码的原理" class="headerlink" title="Base编码的原理"></a>Base编码的原理</h3><p><a href="https://www.cnblogs.com/0yst3r-2046/p/11962942.html">Base系列编码浅析【base16 base32 base64 base85 base36 base 58 base91 base 92 base62】 - 0yst3r - 博客园</a></p>
<h3 id="Base编码的工具"><a href="#Base编码的工具" class="headerlink" title="Base编码的工具"></a>Base编码的工具</h3><p><a href="https://ctf.bugku.com/tools">在线工具 - Bugku CTF</a></p>
<p><a href="https://github.com/mufeedvh/basecrack">mufeedvh/basecrack: Decode All Bases - Base Scheme Decoder</a></p>
<h3 id="在python中实现"><a href="#在python中实现" class="headerlink" title="在python中实现"></a>在python中实现</h3><p>在Python中，可以使用标准库中的 <code>base64</code> 模块实现多种不同的 Base 编码。该模块支持以下几种 Base 编码格式：</p>
<ul>
<li>Base16（也称为 Hex 编码）：使用 16 个字符（0-9 和 A-F）表示二进制数据。</li>
<li>Base32：使用 32 个字符（A-Z 和 2-7）表示二进制数据。</li>
<li>Base64：使用 64 个字符（A-Z、a-z、0-9 和 + /）表示二进制数据。</li>
<li>Base85：使用 85 个字符表示二进制数据，每个字符可以表示 4 个字节。</li>
</ul>
<p>这些编码格式都是基于一组固定的字符集，将二进制数据转换为一串可打印的字符。这些编码格式在实际应用中有不同的优缺点，可以根据需要选择合适的编码格式。</p>
<p>在 <code>base64</code> 模块中，可以使用以下方法来进行不同的编码和解码操作：</p>
<ul>
<li><code>base64.b16encode()</code> 和 <code>base64.b16decode()</code>：用于 Base16 编码和解码。</li>
<li><code>base64.b32encode()</code> 和 <code>base64.b32decode()</code>：用于 Base32 编码和解码。</li>
<li><code>base64.b64encode()</code> 和 <code>base64.b64decode()</code>：用于 Base64 编码和解码。</li>
<li><code>base64.a85encode()</code> 和 <code>base64.a85decode()</code>：用于 Base85 编码和解码。</li>
</ul>
<p>这些方法接受 <strong>bytes 类型</strong>的数据作为输入，并返回 <strong>bytes 类型</strong>的编码结果。如果需要将编码结果转换为字符串类型，可以使用 <code>.decode()</code> 方法将 bytes 对象转换为字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#例子</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要编码的二进制数据</span></span><br><span class="line">data = <span class="string">&#x27;Hello, World!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用base64进行编码</span></span><br><span class="line">encoded_data = base64.b64encode(data)</span><br><span class="line"><span class="built_in">print</span>(encoded_data)  <span class="comment"># 输出 &#x27;SGVsbG8sIFdvcmxkIQ==\n&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用base64进行解码</span></span><br><span class="line">decoded_data = base64.b64decode(encoded_data)</span><br><span class="line"><span class="built_in">print</span>(decoded_data)  <span class="comment"># 输出 &#x27;Hello, World!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把编码结果转换为字符串类型</span></span><br><span class="line">b64_str = b64_data.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b64_str)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>CVE-2022-29221复现</title>
    <url>/2023/05/16/CVE-2022-29221%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<p>上周三WEB组的任务，白神真的会上压力，不过感觉复现一个CVE提升挺大的（特别是配环境环节），一下子弄懂了好多</p>
<span id="more"></span>

<h1 id="CVE-2022-29221复现"><a href="#CVE-2022-29221复现" class="headerlink" title="CVE-2022-29221复现"></a>CVE-2022-29221复现</h1><h2 id="漏洞概述："><a href="#漏洞概述：" class="headerlink" title="漏洞概述："></a>漏洞概述：</h2><blockquote>
<p>Smarty is a template engine for PHP, facilitating the separation of presentation (HTML/CSS) from application logic. Prior to versions 3.1.45 and 4.1.1, template authors could inject php code by choosing a malicious {block} name or {include} file name. Sites that cannot fully trust template authors should upgrade to versions 3.1.45 or 4.1.1 to receive a patch for this issue. There are currently no known workarounds.</p>
<p>Publish Date : 2022-05-24 Last Update Date : 2022-12-08</p>
<p><a href="https://www.cvedetails.com/cve/CVE-2022-29221/">CVE-2022-29221 : Smarty is a template engine for PHP, facilitating the separation of presentation (HTML/CSS) from application logic. Prio</a></p>
<p>翻译：Smarty是一个PHP模板引擎，它可以使显示层(HTML/CSS)和应用逻辑分离。在3.1.45和4.1.1版本之前，模板作者可以通过选择恶意的{block}名称或{include}文件名来注入PHP代码。那些无法完全信任模板作者的网站应该升级到3.1.45或4.1.1版本，以获得此问题的补丁。目前没有已知的解决方法。</p>
</blockquote>
<p><strong>术语解析：</strong></p>
<ul>
<li>模板引擎：一种将数据和表现分离开来的机制，数据和逻辑被封装，而表现则由模板决定。</li>
<li>显示层：也可称表现层或表示层，是软件架构的最外层，负责与用户的交互和数据的可视化。</li>
<li>应用逻辑：也称业务逻辑，是软件开发中实现业务功能和处理业务流程的逻辑代码。</li>
<li>注入：在计算机安全中，注入通常是指恶意的、未经验证的数据被输入到解释器里，导致未预期的命令执行或者访问未授权的数据和程序。</li>
</ul>
<p><strong>漏洞类型：SSTI</strong></p>
<p>（什么是SSTI详情参考SSTI学习笔记）</p>
<h2 id="Smarty模板概述："><a href="#Smarty模板概述：" class="headerlink" title="Smarty模板概述："></a>Smarty模板概述：</h2><p>Smarty是一个主流的采用php编写的模板引擎。其目录文件结构应如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Smarty/</span><br><span class="line">|</span><br><span class="line">|--www.demo.com</span><br><span class="line">	|</span><br><span class="line">	|--cache/*			(缓存目录)</span><br><span class="line">	|--configs/			(设置目录)</span><br><span class="line">		|--test.conf	</span><br><span class="line">	|--plugins/*</span><br><span class="line">	|--templates_c/*		(编译目录)</span><br><span class="line">	|--templates/			(模板目录)</span><br><span class="line">		|--index.tpl</span><br><span class="line">	|--WWW				(页面根目录)</span><br><span class="line">		|--index.php	</span><br><span class="line">|--libs/				(库文件)</span><br><span class="line">	|</span><br><span class="line">	|--Smarty.class.php		(核心文件)</span><br><span class="line">    |--debug.tpl</span><br><span class="line">    |--sysplugins/*</span><br><span class="line">    |--plugins/*</span><br></pre></td></tr></table></figure>

<p>在配置好库文件后，就可以开始为你的网页使用Smarty了。</p>
<p>*官方说明</p>
<ul>
<li>Smarty可配置四个目录，默认名称分别是 <code>templates/</code>, <code>templates_c/</code>, <code>configs/</code> 和 <code>cache/</code>。</li>
<li>这些都分别对应Smarty类的属性定义 <a href="https://www.smarty.net/docs/zh_CN/variable.template.dir.tpl"><code>$template_dir</code></a>, <a href="https://www.smarty.net/docs/zh_CN/variable.compile.dir.tpl"><code>$compile_dir</code></a>, <a href="https://www.smarty.net/docs/zh_CN/variable.config.dir.tpl"><code>$config_dir</code></a>, 和 <a href="https://www.smarty.net/docs/zh_CN/variable.cache.dir.tpl"><code>$cache_dir</code></a>。</li>
<li>强烈建议分别在每个使用Smarty的程序中都单独定义这些目录。</li>
<li>你可以通过<a href="https://www.smarty.net/docs/zh_CN/api.test.install.tpl"><code>testInstall()</code></a> 来测试Smarty是否有权限读写这些目录。</li>
</ul>
<p>*其他</p>
<ul>
<li>模板目录(template dir)存放所有的模板文件，这是开发者编写和维护的目录。</li>
<li>编译目录(compile dir)在模板文件修改后，Smarty会自动重新编译模板，生成对应的PHP文件。</li>
<li>缓存目录(cache dir)存储渲染后的HTML内容。当模板或数据发生变化时，cache目录会被自动清空，forcing Smarty重新渲染所有模板。</li>
</ul>
<p>使用方式：</p>
<p>从github上下载Smarty源码，解压后文档目录为：</p>
<p><img src="/2023/05/16/CVE-2022-29221%E5%A4%8D%E7%8E%B0/.././CVE-2022-29221%E5%A4%8D%E7%8E%B0/image-20230516201359523.png" alt="image-20230516201359523"></p>
<p>关键是libs文件夹，储存着渲染的核心代码。</p>
<p>demo文件夹如图：</p>
<p><img src="/2023/05/16/CVE-2022-29221%E5%A4%8D%E7%8E%B0/.././CVE-2022-29221%E5%A4%8D%E7%8E%B0/image-20230516201436412.png" alt="image-20230516201436412"></p>
<p>为了使用Smarty模板，需要把libs文件夹复制到网站根目录中，然后在目录下建创两个文件夹：templates和templates_c即可。</p>
<p>PS.在使用前，请在本地开启php环境，我采用的是phpstudy</p>
<p>一个简单的使用示例：</p>
<p><img src="/2023/05/16/CVE-2022-29221%E5%A4%8D%E7%8E%B0/.././CVE-2022-29221%E5%A4%8D%E7%8E%B0/image-20230516140331370.png" alt="image-20230516140331370"></p>
<p>网页如图：</p>
<p><img src="/2023/05/16/CVE-2022-29221%E5%A4%8D%E7%8E%B0/.././CVE-2022-29221%E5%A4%8D%E7%8E%B0/image-20230516140346510.png" alt="image-20230516140346510"></p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h3><p>使用phpstudy搭建本地网站即可，再用phpstorm调试，调试的教程自行搜索</p>
<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>在github下载poc：</p>
<p><a href="https://github.com/sbani/CVE-2022-29221-PoC">sbani/CVE-2022-29221-PoC: CVE-2022-29221 Proof of Concept Code - Smarty RCE</a></p>
<p><img src="/2023/05/16/CVE-2022-29221%E5%A4%8D%E7%8E%B0/.././CVE-2022-29221%E5%A4%8D%E7%8E%B0/image-20230516141935696.png" alt="image-20230516141935696"></p>
<p>代码内容如图</p>
<p>打开网页看看效果</p>
<p><img src="/2023/05/16/CVE-2022-29221%E5%A4%8D%E7%8E%B0/.././CVE-2022-29221%E5%A4%8D%E7%8E%B0/image-20230516142025190.png" alt="image-20230516142025190"></p>
<p>可以看到<code>system(whoami)</code>命令已经被执行了，包括后面的ABC字符</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>首先查看修复代码：</p>
<p><a href="https://github.com/smarty-php/smarty/commit/64ad6442ca1da31cefdab5c9874262b702cccddd">Merge branch ‘security/blockfunctioninjection’ · smarty-php/smarty@64ad644</a></p>
<p>关键修改的部分：</p>
<p><img src="/2023/05/16/CVE-2022-29221%E5%A4%8D%E7%8E%B0/.././CVE-2022-29221%E5%A4%8D%E7%8E%B0/image-20230516142213673.png" alt="image-20230516142213673"></p>
<p>同时，在修复代码中，可以看到存在漏洞的是这些文件：</p>
<p><img src="/2023/05/16/CVE-2022-29221%E5%A4%8D%E7%8E%B0/.././CVE-2022-29221%E5%A4%8D%E7%8E%B0/image-20230516192358926.png" alt="image-20230516192358926"></p>
<p>补充：</p>
<p>libs/sysplugins/目录存放了Smarty模板引擎的系统插件，以``libs/sysplugins/smarty_internal_compile_block.php`为例，它是Smarty模板引擎的系统插件文件之一。其主要作用是：解析模板中的块结构，生成PHP代码，实现块的覆盖、继承和输出功能。</p>
<p>Smarty模板中{block}块的作用：<a href="https://www.smarty.net/docs/zh_CN/language.function.block.tpl">{block} | Smarty</a></p>
<p>简而言之，<code>&#123;block&#125;</code>可在模板上定义一块区域，以进行模板继承。</p>
<p>子模板中的<code>&#123;block&#125;</code>区域代码，将会替换父模板对应的区域代码。</p>
<p>另外，<code>&#123;block&#125;</code>可以设置成合并父子模板的相应区域。在子模板的<code>&#123;block&#125;</code>中定义 <code>append</code> 或 <code>prepend</code>，可以使子模板附加在父模板 <code>&#123;block&#125;</code>区域的后面或前面。 在<code>&#123;block&#125;</code>内容中使用{$smarty.block.parent}，可以让父模板的区域代码放到 子模板<code>&#123;block&#125;</code>内的任何位置。</p>
<p>具体过程：</p>
<p>当Smarty编译模板文件时，遇到{block}标签，会调用<code>smarty_internal_compile_block.php</code>这个系统插件进行编译。该插件会执行以下操作：</p>
<ol>
<li><p>获取{block}标签的name属性，作为块名。</p>
</li>
<li><p>如果name属性为空，则使用块内的第一个文本作为name。</p>
</li>
<li><p>检查是否有同名的父级块，如果有，标记为块覆盖。</p>
</li>
<li><p>生成块开始和结束的PHP代码</p>
</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/* &#123;block name&#125; */</span></span><br><span class="line"><span class="comment">//块开始</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">/* &#123;/block&#125; */</span> </span><br><span class="line"><span class="comment">//块结束</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>如果标记为块覆盖，生成的PHP代码中会调用父级块。</li>
<li>递归编译块内的内容。 </li>
<li>如果块被留空，生成的PHP代码会直接调用父级块。</li>
</ol>
<p>回到漏洞，未修复前，存在漏洞的代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$output</span> = <span class="string">&quot;&lt;?php\n&quot;</span>;</span><br><span class="line"><span class="variable">$output</span> .= <span class="string">&quot;/* &#123;block <span class="subst">&#123;$_name&#125;</span>&#125; */\n&quot;</span>;	<span class="comment">//这里是注入点</span></span><br><span class="line"><span class="variable">$output</span> .= <span class="string">&quot;class <span class="subst">&#123;$_className&#125;</span> extends Smarty_Internal_Block\n&quot;</span>;</span><br><span class="line"><span class="variable">$output</span> .= <span class="string">&quot;&#123;\n&quot;</span>;</span><br><span class="line">...<span class="comment">//后面是调用那个函数的内容</span></span><br></pre></td></tr></table></figure>

<p>我们来看看这段代码的结果如何：</p>
<p>先是一个简单的例子演示，假设模板文件中存在这样的代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;block name=&quot;parent&quot;&#125;</span><br><span class="line">   &#123;block name=&quot;child&quot;&#125;</span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span>&gt;</span>Child block<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   &#123;/block&#125;</span><br><span class="line">&#123;/block&#125; </span><br></pre></td></tr></table></figure>

<p>那么编译后生成的php代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/* &#123;block parent&#125; */</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent_child</span> <span class="keyword">extends</span> <span class="title">Smarty_Internal_Block</span></span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">callChild</span>(<span class="params"><span class="variable">$params</span>, <span class="variable">$content</span>, <span class="variable">$template</span>, &amp;<span class="variable">$repeat</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;p&gt;Child block&lt;/p&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* &#123;block child&#125; */</span></span><br><span class="line"><span class="variable language_">$this</span>-&gt;_tag_stack[] = <span class="keyword">array</span>(<span class="string">&#x27;parent_child&#x27;</span>, <span class="keyword">array</span>());</span><br><span class="line"><span class="comment">/* &#123;/block&#125; */</span></span><br><span class="line"><span class="title function_ invoke__">array_pop</span>(<span class="variable">$this</span>-&gt;_tag_stack);</span><br></pre></td></tr></table></figure>

<p>所以，如果给{block}块的“name”参数传入恶意代码，如本漏洞的poc<code>&#123;block name=&quot;poc*/system(&#39;whoami&#39;)/*&quot;&#125;ABC&#123;/block&#125;</code>，就可以通过注释符把原本的代码注释掉，从而实现代码注入。</p>
<p>从poc来看（后面我改成phpinfo();来测试了，不影响结果）</p>
<p><img src="/2023/05/16/CVE-2022-29221%E5%A4%8D%E7%8E%B0/.././CVE-2022-29221%E5%A4%8D%E7%8E%B0/image-20230516142253155.png" alt="image-20230516142253155"></p>
<p>注入后的结果为：</p>
<p><img src="/2023/05/16/CVE-2022-29221%E5%A4%8D%E7%8E%B0/.././CVE-2022-29221%E5%A4%8D%E7%8E%B0/image-20230516195835770.png" alt="image-20230516195835770"></p>
<p>可以看到，编译后的php文件已经实现想要的效果，所以最终合并后的php文件就会执行我们注入的代码，输出phpinfo()信息：</p>
<p><img src="/2023/05/16/CVE-2022-29221%E5%A4%8D%E7%8E%B0/.././CVE-2022-29221%E5%A4%8D%E7%8E%B0/image-20230516142839687.png" alt="image-20230516142839687"></p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>所以以上代码看似实现了模板的继承功能，实际上存在注入漏洞。那么，为什么会产生漏洞呢？</p>
<p>实际上，回到上文存在漏洞的第二句代码：<code>$output .= &quot;/* &#123;block &#123;$_name&#125;&#125; */\n&quot;;</code></p>
<p>这句代码的本来效果，是在Smarty编译后的PHP代码中，为模板块增加注释：<code>/* &#123;block &#123;$_name&#125;&#125; */</code></p>
<p>该注释主要目的是为了方便在调试或修改模板时，快速定位到模板中的功能块。</p>
<p>在Smarty编译后的模板文件(templates_c/*.php)中的注释，默认情况下不会出现在最终渲染的页面中（虽然可以通过配置来开启这项功能，但一般正常的网页不会开启）。因为PHP在执行模板文件时，会自动忽略PHP注释。所以开发者就以为代码是安全的，但是，从上文可以看到，如果注入了恶意代码，则最终渲染出的代码还是会执行。</p>
<p>其他有的没的的补充：</p>
<p>Smarty模板渲染的完整过程主要分为以下几步:</p>
<ol>
<li><p>读取模板文件<br>通过{include file=’xxx.tpl’}或直接指定模板文件$smarty-&gt;display(‘xxx.tpl’)读取模板内容。</p>
</li>
<li><p>编译模板<br> 将模板文件内容编译成PHP代码,输出到templates_c目录。如果模板未修改,则直接读取编译缓存。</p>
</li>
<li><p>执行编译结果<br>执行templates_c目录下的PHP文件,渲染模板逻辑与输出。</p>
</li>
<li><p>读取配置文件<br>Smarty会自动加载configs目录下的配置文件,设置全局变量、权限等。</p>
</li>
<li><p>缓存结果<br>Smarty默认会缓存模板渲染结果,输出到cache目录。如果模板或数据未修改,会直接输出缓存内容。</p>
</li>
<li><p>处理模板函数、变量、逻辑等<br>编译模板过程中,Smarty处理模板中用到的函数、变量、条件语句、循环等逻辑。</p>
</li>
<li><p>处理标签插件</p>
<p>Smarty使用标签插件扩展其功能,在渲染过程中加载并执行标签插件。</p>
</li>
<li><p>输出渲染结果<br>最终Smarty输出渲染好的HTML内容。</p>
</li>
</ol>
<p>其他补充：</p>
<p>使用Smarty模板获取参数内容的方式：</p>
<ol>
<li>获取SESSION参数</li>
</ol>
<p>使用<code>&#123;$smarty.session.name&#125;</code>获取SESSION中name的参数值。<br>例如,在PHP页面设置SESSION为:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;user&#x27;</span>] = <span class="string">&#x27;John&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>然后在模板中可以获取:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;$smarty.session.user&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">John</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>获取GET参数</li>
</ol>
<p>使用<code>&#123;$smarty.get.var&#125;</code>获取GET请求中的var参数值。<br>例如，页面URL是:</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">/index.php?name=Jack&amp;age=20</span><br></pre></td></tr></table></figure>

<p>在模板中:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;$smarty.get.name&#125;  &#123;$smarty.get.age&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jack 20</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>获取POST参数</li>
</ol>
<p>使用<code>&#123;$smarty.post.var&#125;</code>获取POST请求中的var参数值。<br>例如，在PHP页面获取POST数据:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$name</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;name&#x27;</span>]; </span><br><span class="line"><span class="variable">$age</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;age&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>在模板中:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;$smarty.post.name&#125;  &#123;$smarty.post.age&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jack 20 </span><br></pre></td></tr></table></figure>

<ol start="4">
<li>直接从$smarty变量获取 </li>
</ol>
<p>如果在PHP中有这样的赋值:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$smarty</span>-&gt;<span class="title function_ invoke__">assign</span>(<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;John&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>则在模板中可以通过<code>&#123;$user&#125;</code>直接获取:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;$user&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">John</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/04/07/Hello-World/</url>
    <content><![CDATA[<h1 id="未竟之旅"><a href="#未竟之旅" class="headerlink" title="未竟之旅"></a>未竟之旅</h1><p>记录一下第一篇文章</p>
<span id="more"></span>

<h2 id="从0开始的部落格搭建"><a href="#从0开始的部落格搭建" class="headerlink" title="从0开始的部落格搭建"></a>从0开始的部落格搭建</h2><p>呃呃，很难说这个部落格，目前也算是能用起来了（能跑就是win）。</p>
<p>说说搭建的历史吧，可能是因为懒（废话就是）本想着去年就搭起来的，但是去年自己啥也不懂（今年好像也是呜呜呜呜），瞎搞了一个服务器，但是弄了半天没弄出来，直接放弃。今年采用这个静态页面托管，上线效率确实快，弄了一两节课就好了。（然而diy弄了一天）</p>
<p>目前就是，摁，在这里分享自己的技术学习吧（虽然我很菜的），以后可能考虑上线别的东西，可能是一些生活记录啥的（先鸽吧，鼠鼠是没有线虫生活的）</p>
<p>瞎寄吧说了半天，希望这个博客能活得长一点，能多分享技术，暂定今年发表100篇技术博客捏~ (￣▽￣) ~*（虽然感觉会鸽，anyway，先把flag立在这了）</p>
<hr>
<h2 id="有关博客搭建的事项"><a href="#有关博客搭建的事项" class="headerlink" title="有关博客搭建的事项"></a>有关博客搭建的事项</h2><p>好吧进入正题，把这次搭建博客的一些经验感悟先记录在这，供自己和他人以后参考</p>
<h3 id="可能需要了解的前置知识"><a href="#可能需要了解的前置知识" class="headerlink" title="可能需要了解的前置知识"></a>可能需要了解的前置知识</h3><p>什么是网站和网页？什么是服务器和域名？什么是……</p>
<p>——互联网黑话初入门</p>
<h3 id="我的博客配置"><a href="#我的博客配置" class="headerlink" title="我的博客配置"></a>我的博客配置</h3><p>目前采用的是Hexo</p>
<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><h3 id="其他插件"><a href="#其他插件" class="headerlink" title="其他插件"></a>其他插件</h3><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3>]]></content>
      <categories>
        <category>freeTalk</category>
      </categories>
      <tags>
        <tag>talkingToMyself</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/04/06/index/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>一些杂项</title>
    <url>/2023/04/19/%E4%B8%80%E4%BA%9B%E6%9D%82%E9%A1%B9/</url>
    <content><![CDATA[<p> 一些无意发现的东西</p>
<span id="more"></span>

<h2 id="设计心理学？"><a href="#设计心理学？" class="headerlink" title="设计心理学？"></a>设计心理学？</h2><p>哥们以前任务栏图标</p>
<p><img src="/2023/04/19/%E4%B8%80%E4%BA%9B%E6%9D%82%E9%A1%B9/.././%E4%B8%80%E4%BA%9B%E6%9D%82%E9%A1%B9/image-20230419000435176.png" alt="image-20230419000435176"></p>
<p>这样经常会点错，想选择谷歌浏览器会点到edge</p>
<p>然后这样改了</p>
<p><img src="/2023/04/19/%E4%B8%80%E4%BA%9B%E6%9D%82%E9%A1%B9/.././%E4%B8%80%E4%BA%9B%E6%9D%82%E9%A1%B9/image-20230419000518990.png" alt="image-20230419000518990"></p>
<p>欸，莫名其妙就不会误触了！</p>
<p>嗯，可见分隔不同属性的优点</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2>]]></content>
      <categories>
        <category>development</category>
      </categories>
  </entry>
  <entry>
    <title>PHP代码审计学习笔记（施工中）</title>
    <url>/2023/05/10/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%96%BD%E5%B7%A5%E4%B8%AD%EF%BC%89/</url>
    <content><![CDATA[<p>一点PHPtricks，正在学习更新中</p>
<p>“PHP是世界上最好的语言” ^^</p>
<span id="more"></span>

<h1 id="PHP代码审计学习笔记（施工中）"><a href="#PHP代码审计学习笔记（施工中）" class="headerlink" title="PHP代码审计学习笔记（施工中）"></a>PHP代码审计学习笔记（施工中）</h1><h2 id="PHP弱类型比较"><a href="#PHP弱类型比较" class="headerlink" title="PHP弱类型比较"></a>PHP弱类型比较</h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>PHP是一门弱类型语言,这意味着同一变量可以在不同时间存放不同类型的数据。由于PHP的弱类型特征,在部分比较操作符（== 、&gt; 、&lt; 等）比较<strong>不同类型的数据</strong>时，会进行<strong>类型转换</strong>后再比较，这可能导致一些非预期的结果。</p>
<h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p><strong>一、字符串与整型比较</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;10&#x27;</span> == <span class="number">10</span>        <span class="comment">// true </span></span><br><span class="line"><span class="string">&#x27;10&#x27;</span> === <span class="number">10</span>       <span class="comment">// false</span></span><br><span class="line"><span class="string">&#x27;10foo&#x27;</span> &gt; <span class="number">5</span>        <span class="comment">// true </span></span><br></pre></td></tr></table></figure>

<p>在 == 比较时，字符串’10’会转换为整型10，所以相等。但 === 全等比较不会发生类型转换，所以不相等。<br>在 &gt; 比较时，’10foo’ 被解析为10，所以 ‘10foo’ &gt; 5返回true。</p>
<p><strong>二、空字符串与零比较</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="number">0</span>           <span class="comment">// true </span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> === <span class="number">0</span>          <span class="comment">// false </span></span><br></pre></td></tr></table></figure>

<p> 在 == 比较中，空字符串 ‘’ 被转换为0，所以相等。但 === 全等比较不转换类型,所以不相等。</p>
<p>注：<strong>0、[]、[0]、null</strong>和任意字符进行<strong>弱类型比较</strong>都相等</p>
<p><strong>三、空数组与零比较</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">[] == <span class="number">0</span>           <span class="comment">// true </span></span><br><span class="line">[] === <span class="number">0</span>          <span class="comment">// false </span></span><br></pre></td></tr></table></figure>

<p> [] 被转换为0进行 == 比较，所以相等。但===不会转换类型,所以不相等。</p>
<p><strong>四、空与 NULL 比较</strong> </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="literal">null</span>        <span class="comment">// true </span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> === <span class="literal">null</span>       <span class="comment">// false </span></span><br></pre></td></tr></table></figure>

<p> == 比较时，null被转换为 ‘’ ，所以相等。但===不会转换类型,所以不相等。</p>
<h3 id="常见的利用类型"><a href="#常见的利用类型" class="headerlink" title="常见的利用类型"></a>常见的利用类型</h3><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://flag0.com/2019/09/20/php%E5%BC%B1%E7%B1%BB%E5%9E%8B/">php弱类型、强类型总结 | flag0’s Blog</a></p>
<h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><h5 id="md5绕过的技巧"><a href="#md5绕过的技巧" class="headerlink" title="md5绕过的技巧"></a>md5绕过的技巧</h5><p><a href="https://cloud.tencent.com/developer/beta/article/2070130">关于md5的绕过技巧-腾讯云开发者社区-腾讯云</a></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$str1</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;str1&#x27;</span>];</span><br><span class="line"><span class="variable">$str2</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;str2&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">md5</span>(<span class="variable">$str1</span>) == <span class="title function_ invoke__">md5</span>(<span class="variable">$str2</span>))&#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&#x27;OK&#x27;</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//?str1 = s1885207154a&amp;str2 = s1091221200a</span></span><br></pre></td></tr></table></figure>

<p>注意到比较的时候是弱类型比较，所以……</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$str1</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;str1&#x27;</span>];</span><br><span class="line"><span class="variable">$str2</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;str2&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">md5</span>(<span class="variable">$str1</span>) === <span class="title function_ invoke__">md5</span>(<span class="variable">$str2</span>)) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&#x27;OK&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//?str1[]=1&amp;str2[]=2</span></span><br></pre></td></tr></table></figure>

<p>PHP自身的特性使得可以提交一个数组，而md5函数传入数组的返回值都是NULL，这样就可以绕过强类型比较了。所以这里用GET传入就行了</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$str1</span> = (<span class="keyword">string</span>)<span class="variable">$_GET</span>[<span class="string">&#x27;str1&#x27;</span>];</span><br><span class="line"><span class="variable">$str2</span> = (<span class="keyword">string</span>)<span class="variable">$_GET</span>[<span class="string">&#x27;str2&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">md5</span>(<span class="variable">$str1</span>) === <span class="title function_ invoke__">md5</span>(<span class="variable">$str2</span>)) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&#x27;OK&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于强制类型转换，所以不能传入数组了，这里就需要MD5碰撞：</p>
<p>一个关于md5碰撞功能的网页：<a href="https://www.win.tue.nl/hashclash/">HashClash</a></p>
<h5 id="其他例子："><a href="#其他例子：" class="headerlink" title="其他例子："></a>其他例子：</h5><p><strong>绕过is_numeric()函数：</strong></p>
<p>is_numeric()用于判断变量是否为数字，但是它实际检测的是<strong>变量是否可以转换为数字</strong>。所以:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">is_numeric</span>(<span class="string">&#x27;1foo&#x27;</span>)   <span class="comment">// true </span></span><br><span class="line"><span class="title function_ invoke__">is_numeric</span>(<span class="string">&#x27;foo1&#x27;</span>)   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>‘1foo’ 可以转换为1，所以返回true。攻击者可以通过构造类似 ‘1e10’ 来绕过is_numeric()检测。</p>
<p><strong>利用隐式类型转换绕过空验证：</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>] != <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Welcome <span class="subst">&#123;$_GET[&#x27;name&#x27;]&#125;</span>&quot;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码试图避免空字符串注入，但是攻击者可以发送name=0或name=1。因为PHP会将其隐式转换为字符串 ‘0’ 或 ‘1’ 。</p>
<p><strong>利用JSON绕过magic_quotes_gpc：</strong></p>
<p>PHP的魔术引号magic_quotes_gpc可以自动对POST、GET、COOKIE数据进行转义，来防范SQL注入。但是，当magic_quotes_gpc开启时，攻击者可以通过JSON数据绕过:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">POST: &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;xiaoming&#x27; OR 1=1 #&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$data</span> = <span class="title function_ invoke__">json_decode</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;data&#x27;</span>]);</span><br><span class="line"><span class="variable">$name</span> = <span class="variable">$data</span>-&gt;name;   <span class="comment">// $name = xiaoming&#x27; OR 1=1 #</span></span><br></pre></td></tr></table></figure>

<p>因为json_decode()会解析JSON并返回object，魔术引号不会对其转义。</p>
<p><strong>利用数组绕过stripslashes()：</strong></p>
<p>stripslashes()用于去除反斜杠转义，如果传入双引号字符串，它可以有效防止SQL注入。但是，攻击者可以通过数组绕过:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM users WHERE name = <span class="subst">&#123;$_GET[&#x27;name&#x27;]&#125;</span>&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">get_magic_quotes_gpc</span>()) &#123;</span><br><span class="line">    <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>] = <span class="title function_ invoke__">stripslashes</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>利用数组绕过preg_match()：</strong></p>
<p>preg_match()用于正则匹配，如果传入字符串会有效防止SQL注入。但是，攻击者可以发送数组绕过:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM users WHERE name = <span class="subst">&#123;$_GET[&#x27;name&#x27;]&#125;</span>&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/^[a-zA-Z0-9_]+$/&#x27;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>])) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>攻击者可以发送 GET 参数为 <code>name[]=1&#39;</code> ，产生 <code>$sql = &quot;SELECT * FROM users WHERE name = [1&#39;]&quot;</code> 成功绕过。</p>
<p><strong>利用对象绕过 stripslashes()：</strong></p>
<p>stripslashes()可以通过数组绕过，也可以通过对象绕过:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>] = <span class="title function_ invoke__">stripslashes</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line"><span class="variable">$name</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>攻击者可以构造:<code>POST: &#123;&quot;name&quot;: &#123;&quot;value&quot;: &quot;xiaoming&#39; OR 1=1 #&quot; &#125;&#125;</code></p>
<p>这会产生 <code>$name = &#123;&quot;value&quot;: &quot;xiaoming&#39; OR 1=1 # &quot;&#125;</code>，成功绕过stripslashes()。</p>
<p><strong>利用 JSON 绕过 mysql_real_escape_string()：</strong></p>
<p>和之前提到的利用JSON绕过magic_quotes_gpc类似，攻击者也可以利用JSON绕过mysql_real_escape_string():</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$name</span> = <span class="title function_ invoke__">mysql_real_escape_string</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM users WHERE name = &#x27;<span class="subst">$name</span>&#x27;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>攻击者发送<code>POST: &#123;&quot;name&quot;: &quot;xiaoming&#39; OR 1=1 # &quot;&#125; </code></p>
<p>这会产生 <code>$sql = &quot;SELECT * FROM users WHERE name = &#39;xiaoming\&#39; OR 1=1 # &#39;&quot;</code>，成功SQL注入。</p>
<p><strong>利用十六进制绕过preg_match()preg_match()：</strong></p>
<p>在匹配字符串时不会验证十六进制编码的数据，攻击者可以利用这点绕过：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/^[\da-z]+$/i&#x27;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;input&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM users WHERE name = <span class="subst">&#123;$_GET[&#x27;input&#x27;]&#125;</span>&quot;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>攻击者可以发送input=0x78，这会产生 <code>$sql = &quot;SELECT * FROM users WHERE name = 0x78&quot;</code> ，成功绕过正则匹配的验证。</p>
<p>其他更多姿势等待搜集整理，关键还是在弱类型比较中会产生<strong>类型转换</strong></p>
<h2 id="PHP代码注入"><a href="#PHP代码注入" class="headerlink" title="PHP代码注入"></a>PHP代码注入</h2><p>（目前没遇到太多，具体操作不是很清晰）</p>
<h3 id="简述："><a href="#简述：" class="headerlink" title="简述："></a>简述：</h3><p>PHP代码注入是一种代码执行漏洞，它允许攻击者向应用提交恶意代码，由应用执行。这通常是由于应用直接在PHP中执行<strong>用户提交的数据</strong>造成的。</p>
<h3 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h3><p>PHP代码注入的形成是因为PHP支持<strong>动态语句执行</strong>和<strong>变量解析替换</strong>。当用户输入的数据被直接用于动态构造语句时，攻击者可以通过特殊构造输入将其作为PHP代码执行，这就导致了代码注入。</p>
<h3 id="简单例子："><a href="#简单例子：" class="headerlink" title="简单例子："></a>简单例子：</h3><p><strong>获取系统信息</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$input</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;input&#x27;</span>];</span><br><span class="line">    <span class="keyword">eval</span>(<span class="variable">$input</span>);  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>访问:<code>?input=phpinfo();</code>这会执行phpinfo()函数显示PHP配置信息。</p>
<p><strong>读取敏感文件</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="variable">$file</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>访问:<code>?file=index.php</code>这会显示index.php文件的源代码。</p>
<p><strong>执行系统命令</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$cmd</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]; </span><br><span class="line">    <span class="title function_ invoke__">system</span>(<span class="variable">$cmd</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>访问:?cmd=whoami<br>这会执行whoami命令显示当前用户。</p>
<p>以上样例演示了php部分函数能直接执行提交的恶意数据，导致非预期的结果，实际中可能会有多种过滤和函数禁用，需要具体情况具体分析，查阅PHP手册进行绕过</p>
<h3 id="危险的函数："><a href="#危险的函数：" class="headerlink" title="危险的函数："></a>危险的函数：</h3><p>代码执行函数：eval()， assert(), </p>
<p>正则匹配函数：preg_replace(), </p>
<p>动态代码执行函数：create_function()，call_user_func()，call_user_func_array()。</p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://3wapp.github.io/WebSecurity/php_cmdinject.html">PHP代码执行与命令注入 · Wiki | janes</a></p>
<p><a href="http://www.beesfun.com/2017/04/18/PHP%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E5%92%8C%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/">PHP代码注入和命令注入 | bees’ blog</a></p>
<p><a href="https://blog.csdn.net/qq_41901122/article/details/104244366">PHP 代码注入知识点总结_if (isset(_星球守护者的博客-CSDN博客</a></p>
<p><a href="https://www.freebuf.com/column/166385.html">PHP代码命令注入小结 - FreeBuf网络安全行业门户</a></p>
<p>[<a href="https://www.cnblogs.com/jpSpaceX/articles/14900803.html">渗透测试]：PHP代码注入 - jpSpaceX - 博客园</a></p>
<h2 id="PHP伪协议"><a href="#PHP伪协议" class="headerlink" title="PHP伪协议"></a>PHP伪协议</h2><p>（感觉遇到了会用就行，前人已经总结得很完善了，就不再造轮子了）</p>
<p>简述：PHP伪协议是PHP代码中使用的特殊协议,它允许读取本地数据流、文件等资源。</p>
<p>利用方式：</p>
<p><a href="https://segmentfault.com/a/1190000018991087">PHP伪协议总结 - 个人文章 - SegmentFault 思否</a></p>
<p><a href="https://www.cnblogs.com/wjrblogs/p/12285202.html">CTF中常用的php伪协议利用 - 1ndex- - 博客园</a></p>
<p><a href="https://www.hetianlab.com/hetian/20210906145653">PHP伪协议的妙用 - 合天网安实验室</a></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>一些稀奇古怪的问题的记录与解决</title>
    <url>/2023/04/17/%E4%B8%80%E4%BA%9B%E7%A8%80%E5%A5%87%E5%8F%A4%E6%80%AA%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95%E4%B8%8E%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>如题所示，希望这些debug过程能提供一些参考，或者是自己以后忘了回来看看</p>
<span id="more"></span>

<h1 id="一些稀奇古怪的问题的记录和解决"><a href="#一些稀奇古怪的问题的记录和解决" class="headerlink" title="一些稀奇古怪的问题的记录和解决"></a>一些稀奇古怪的问题的记录和解决</h1><h2 id="chrome复制链接无法复制标题"><a href="#chrome复制链接无法复制标题" class="headerlink" title="chrome复制链接无法复制标题"></a>chrome复制链接无法复制标题</h2><p><strong>问题背景：</strong>经常在写文档或者查找资料的时候需要搜索网页，搜索完之后需要保存下来，但是chrome复制网页链接无法做到连同标题一起复制，导致回顾的时候常常不记得这个链接的大概内容，有时候一个临时文本框存了很多链接，自己看的也懵。使用edge后发现edge可以做到，就想着chrome也一定可以。</p>
<p><strong>解决方案：</strong>谷歌插件市场下载tapcopy插件，这款插件可以实现复制链接携带标题的功能，还可以自行选择格式，例如适用于md，html，js等等，甚至可以自定义格式</p>
<p><img src="/2023/04/17/%E4%B8%80%E4%BA%9B%E7%A8%80%E5%A5%87%E5%8F%A4%E6%80%AA%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95%E4%B8%8E%E8%A7%A3%E5%86%B3/.././%E4%B8%80%E4%BA%9B%E7%A8%80%E5%A5%87%E5%8F%A4%E6%80%AA%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95%E4%B8%8E%E8%A7%A3%E5%86%B3/image-20230417150612785.png" alt="image-20230417150612785"></p>
<p><img src="/2023/04/17/%E4%B8%80%E4%BA%9B%E7%A8%80%E5%A5%87%E5%8F%A4%E6%80%AA%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95%E4%B8%8E%E8%A7%A3%E5%86%B3/.././%E4%B8%80%E4%BA%9B%E7%A8%80%E5%A5%87%E5%8F%A4%E6%80%AA%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95%E4%B8%8E%E8%A7%A3%E5%86%B3/image-20230417150645544.png" alt="image-20230417150645544"></p>
]]></content>
      <categories>
        <category>development</category>
      </categories>
      <tags>
        <tag>deBug</tag>
      </tags>
  </entry>
  <entry>
    <title>数字电路复习</title>
    <url>/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p>考试周到了，快死掉了，赶紧复习。（因为还不习惯latex的语法，所以有些内容放不上来，只能文字叙述）</p>
<p>总结一下数电要考的重点内容还有注意事项？应该是，具体的题目参看课本例题和课后作业。</p>
<span id="more"></span>

<h1 id="数字电路复习"><a href="#数字电路复习" class="headerlink" title="数字电路复习"></a>数字电路复习</h1><h2 id="第一章——数字电路基础（ez，了解即可）"><a href="#第一章——数字电路基础（ez，了解即可）" class="headerlink" title="第一章——数字电路基础（ez，了解即可）"></a>第一章——数字电路基础（ez，了解即可）</h2><h3 id="数制转换（会用，能算）"><a href="#数制转换（会用，能算）" class="headerlink" title="数制转换（会用，能算）"></a>数制转换（会用，能算）</h3><p>进位计数制</p>
<p>2进制与10进制（整数和小数）的相互转换——<strong>除k求余法</strong>和<strong>乘k取整法</strong></p>
<p>2进制与8、16进制的相互转换</p>
<h3 id="常用编码（了解即可）"><a href="#常用编码（了解即可）" class="headerlink" title="常用编码（了解即可）"></a>常用编码（了解即可）</h3><h4 id="BCD码（会考BCD码之间和二进制数的转换）"><a href="#BCD码（会考BCD码之间和二进制数的转换）" class="headerlink" title="BCD码（会考BCD码之间和二进制数的转换）"></a>BCD码（会考BCD码之间和二进制数的转换）</h4><p>8421码，2421码（一般不考，因为有多种实现方式），余3码（8421码+3，即0011）</p>
<h4 id="机器码（以前的试卷出现过，了解即可）"><a href="#机器码（以前的试卷出现过，了解即可）" class="headerlink" title="机器码（以前的试卷出现过，了解即可）"></a>机器码（以前的试卷出现过，了解即可）</h4><p>原码：正数符号位为0，等于真值；负数符号位为1，等于真值。</p>
<p>反码：正数与原码相同；负数为原码取反。</p>
<p>补码：正数与原码相同；负数为反码加1。</p>
<h4 id="可靠性编码（在组合逻辑电路可能会让实现功能或者作为结果分析，了解逻辑表达式即可）"><a href="#可靠性编码（在组合逻辑电路可能会让实现功能或者作为结果分析，了解逻辑表达式即可）" class="headerlink" title="可靠性编码（在组合逻辑电路可能会让实现功能或者作为结果分析，了解逻辑表达式即可）"></a>可靠性编码（在组合逻辑电路可能会让实现功能或者作为结果分析，了解逻辑表达式即可）</h4><h5 id="奇偶检验码："><a href="#奇偶检验码：" class="headerlink" title="奇偶检验码："></a>奇偶检验码：</h5><p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412204828101.png" alt="image-20230412204828101"></p>
<p>ps.奇校验可以通过最后XOR1实现</p>
<p>奇偶校验码基本原理：</p>
<ul>
<li>奇数个1，它的和数总是1</li>
<li>偶数个1，它的和数总是0</li>
</ul>
<h5 id="格雷码："><a href="#格雷码：" class="headerlink" title="格雷码："></a>格雷码：</h5><p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412205038008.png" alt="image-20230412205038008"></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412205029561.png" alt="image-20230412205029561"></p>
<h4 id="字符编码：基本不考"><a href="#字符编码：基本不考" class="headerlink" title="字符编码：基本不考"></a>字符编码：基本不考</h4><h2 id="第二章——逻辑代数（主要是逻辑表达式的化简和卡诺图的化简，其他零碎的知识点知道就好）"><a href="#第二章——逻辑代数（主要是逻辑表达式的化简和卡诺图的化简，其他零碎的知识点知道就好）" class="headerlink" title="第二章——逻辑代数（主要是逻辑表达式的化简和卡诺图的化简，其他零碎的知识点知道就好）"></a>第二章——逻辑代数（主要是逻辑表达式的化简和卡诺图的化简，其他零碎的知识点知道就好）</h2><h3 id="逻辑代数基本定理和规则（了解即可，熟悉黑体部分）"><a href="#逻辑代数基本定理和规则（了解即可，熟悉黑体部分）" class="headerlink" title="逻辑代数基本定理和规则（了解即可，熟悉黑体部分）"></a>逻辑代数基本定理和规则（了解即可，熟悉黑体部分）</h3><p><strong>基本知识</strong>：逻辑代数的概念；五大公理（交换、结合、分配、0-1、互补）；与、或、非三种基本运算；逻辑函数的概念及定理；3大规则（代入、<strong>反演</strong>、<strong>对偶</strong>）；复合逻辑（与非、或非、与或非、<strong>异或</strong>、同或）；逻辑表达式的形式（与-或项，或-与项；最小项，最大项）</p>
<p>以上内容除了加粗部分得知道是怎么回事，其他的了解即可。</p>
<p><strong>逻辑函数的表示方法及其转换</strong></p>
<ul>
<li>逻辑表达式</li>
<li>真值表</li>
<li><strong>卡诺图</strong></li>
<li>电路图</li>
</ul>
<p><strong>异或</strong></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412210627259.png" alt="image-20230412210627259"></p>
<p><strong>逻辑函数的标准形式</strong>（这两个内容挺无语的，有时候会考到，了解就好）</p>
<p>最小项性质</p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412210810400-1681304891735-1.png" alt="image-20230412210810400"></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412210850120.png" alt="image-20230412210850120"></p>
<p>最大项性质</p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412210914704.png" alt="image-20230412210914704"></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412210956430.png" alt="image-20230412210956430"></p>
<p>最小项和最大项的关系：</p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412211036934.png" alt="image-20230412211036934"></p>
<h3 id="逻辑函数的化简"><a href="#逻辑函数的化简" class="headerlink" title="逻辑函数的化简"></a>逻辑函数的化简</h3><h4 id="代数化简法（掌握好代数化简法就可以解决考试和作业中出现的化简题目了）"><a href="#代数化简法（掌握好代数化简法就可以解决考试和作业中出现的化简题目了）" class="headerlink" title="代数化简法（掌握好代数化简法就可以解决考试和作业中出现的化简题目了）"></a>代数化简法（掌握好代数化简法就可以解决考试和作业中出现的化简题目了）</h4><ul>
<li>并项法</li>
<li>吸收法</li>
<li>消去法</li>
<li>配项法</li>
</ul>
<h4 id="卡诺图化简法（这个要熟练，因为后面逻辑电路也会用到卡诺图）"><a href="#卡诺图化简法（这个要熟练，因为后面逻辑电路也会用到卡诺图）" class="headerlink" title="卡诺图化简法（这个要熟练，因为后面逻辑电路也会用到卡诺图）"></a>卡诺图化简法（这个要熟练，因为后面逻辑电路也会用到卡诺图）</h4><p>卡诺图的画法</p>
<p>卡诺图的化简</p>
<p>约束项</p>
<h2 id="第三章——组合逻辑电路分析和设计（主要是中型组合逻辑元件，还有设计题）"><a href="#第三章——组合逻辑电路分析和设计（主要是中型组合逻辑元件，还有设计题）" class="headerlink" title="第三章——组合逻辑电路分析和设计（主要是中型组合逻辑元件，还有设计题）"></a>第三章——组合逻辑电路分析和设计（主要是中型组合逻辑元件，还有设计题）</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>了解基本逻辑门电路</p>
<p><strong>分析的基本步骤</strong></p>
<ol>
<li>明确<strong>输入输出</strong></li>
<li>根据电路<strong>写出逻辑表达式</strong></li>
<li>根据卡诺图<strong>化简</strong>，写出真值表</li>
<li>根据真值表<strong>判断功能</strong></li>
</ol>
<p><strong>逻辑函数形式的变换</strong>（以与或项为例，或与项求两次对偶即可，不重要，了解即可）</p>
<ul>
<li>与非门实现：两次求反，一次展开</li>
<li>或非门实现：一次对偶，两次求反，再次对偶</li>
<li>与或非门实现：两次求反</li>
</ul>
<p><strong>设计组合逻辑电路</strong>（会有大题）</p>
<ul>
<li>设置逻辑变量，明确<strong>输入输出</strong></li>
<li>根据功能列出<strong>真值表</strong></li>
<li>根据真值表得到<strong>逻辑表达式</strong>（也有的可以直接得到），再<strong>化简</strong>为最简逻辑表达式（若有无关项，可以借助化简）</li>
<li>根据化简结果选择<strong>要求的逻辑门</strong>实现</li>
</ul>
<p>这个没啥好说的，建议是看一些课本例题和往年例题，熟悉几道即可。</p>
<p>一般能列出真值表后面的就ez了，</p>
<h3 id="竞争与险象（了解，会判断即可）"><a href="#竞争与险象（了解，会判断即可）" class="headerlink" title="竞争与险象（了解，会判断即可）"></a>竞争与险象（了解，会判断即可）</h3><p><strong>判断险象</strong></p>
<p>有无<strong>同时</strong>出现原变量与反变量</p>
<ul>
<li>或形式：0型险象（因为原变量和反变量相或本该是1，但是由于延迟导致为0）</li>
<li>与形式：1型险象（因为原变量和反变量相与本该是0，但是由于延迟导致为1）</li>
</ul>
<p>卡诺圈<strong>相切</strong>法（看ppt一看就会）</p>
<p><strong>险象的消除</strong></p>
<ol>
<li>增加冗余项<ol>
<li>代数定理增加</li>
<li>卡诺圈增加使其不相切</li>
</ol>
</li>
<li>加选通脉冲</li>
<li>接滤波电容</li>
</ol>
<h3 id="中规模组合逻辑器件"><a href="#中规模组合逻辑器件" class="headerlink" title="中规模组合逻辑器件"></a>中规模组合逻辑器件</h3><p><strong>注意：</strong></p>
<ul>
<li>一般会考<strong>看图写话</strong>，给你一个已经拼好的器件，让你写出表达式，真值表，判断功能等，这种得熟悉元件的<strong>器件图</strong>（重点是数据选择器），<strong>功能表</strong>，<strong>逻辑表达式</strong></li>
<li>注意各种器件的<strong>拓展</strong>，能使端的使用</li>
<li>全加器，全减器需要知道电路图和逻辑表达式（最好能一眼出），可能会直接拿来做分析题</li>
<li>比较器需要熟悉逻辑表达式，可能会直接拿来做分析题</li>
<li>若要求用加法器实现，注意找输入与输出的数值关系</li>
</ul>
<h4 id="数据选择器（熟练）"><a href="#数据选择器（熟练）" class="headerlink" title="数据选择器（熟练）"></a>数据选择器（熟练）</h4><p><strong>元件图、功能表、逻辑表达式</strong>（这张图忽略了能使端）</p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230413221709919.png" alt="image-20230413221709919"></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412214151845.png" alt="image-20230412214151845"></p>
<p><strong>拓展</strong></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230413221840644.png" alt="image-20230413221840644"></p>
<p>（这个思路二没见考过，没时间建议直接跳过，资料上有）</p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230413222022810.png" alt="image-20230413222022810"></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230413222055918.png" alt="image-20230413222055918"></p>
<p><strong>应用：实现逻辑函数（只要能化成最小项，就能实现逻辑函数，又所有的表达式都能化为最小项，所以数据选择器能实现所有的逻辑函数）</strong></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412214312410.png" alt="image-20230412214312410"></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412214326048.png" alt="image-20230412214326048"></p>
<h4 id="译码器"><a href="#译码器" class="headerlink" title="译码器"></a>译码器</h4><h5 id="二进制译码器（关键是表达式）"><a href="#二进制译码器（关键是表达式）" class="headerlink" title="二进制译码器（关键是表达式）"></a>二进制译码器（关键是表达式）</h5><p><strong>元件图、功能表、逻辑表达式</strong></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230413223328019.png" alt="image-20230413223328019"></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230413222702360.png" alt="image-20230413222702360"></p>
<p><strong>拓展</strong></p>
<p>只需要将<strong>能使端用非门连接</strong>即可</p>
<p><strong>应用</strong>（待填坑）</p>
<h5 id="2-10进制译码器（简单了解即可）"><a href="#2-10进制译码器（简单了解即可）" class="headerlink" title="2-10进制译码器（简单了解即可）"></a>2-10进制译码器（简单了解即可）</h5><p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230413230235962.png" alt="image-20230413230235962"></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230413230300881.png" alt="image-20230413230300881"></p>
<h5 id="7段显示译码器（期中考了）"><a href="#7段显示译码器（期中考了）" class="headerlink" title="7段显示译码器（期中考了）"></a>7段显示译码器（期中考了）</h5><p>由<strong>译码器</strong>+<strong>显示器组成</strong></p>
<p>元件图、功能表</p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/681397236753.jpg" alt="681397236753"></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230413224114448.png" alt="image-20230413224114448"></p>
<p>其他说明：（结合上图的理解）</p>
<ul>
<li>灯测试输入LT非：检验其能否正常发光，为0时，a~g全为1，显示8，为0时，不影响，因此正常工作时应设为0</li>
<li>灭零输入RBI非（上图消隐段）：目的是不让显示的0熄灭，当其为0，且当A3A2A1A0=0000时，则灭灯</li>
<li>灭灯输入BI非：只要其为0，不论输入，都熄灭，因此正常工作时应设为1</li>
<li>灭零输出RBO非：只有A3A2A1A0=0000，且灭零输入RBI非=0时，才给出低电平输出，因此当其输出为0时，表示本该显示的0熄灭了</li>
</ul>
<h4 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h4><p>普通编码器元件图和优先编码器基本相同，但是同一时刻只允许一个信号输入。</p>
<h5 id="优先编码器（考过拓展）"><a href="#优先编码器（考过拓展）" class="headerlink" title="优先编码器（考过拓展）"></a>优先编码器（考过拓展）</h5><p>优先编码器为低电平有效，同一时刻允许多个输入，但是高位优先。</p>
<p>注意<strong>优先编码</strong>的含义，有时设计题会考到优先编码的题。</p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412214738799.png" alt="image-20230412214738799"></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230413235341831.png" alt="image-20230413235341831"></p>
<p>逻辑表达式就是A，B，C对应的为1的输入相或。</p>
<p>其他：</p>
<p>从真值表可以看出</p>
<ul>
<li>Is非选通端意为<strong>电路开关</strong>：当其为1时，输出被锁定，所有输入都无效，只有为0时才工作</li>
<li>Os选通端意为<strong>信号有效开关</strong>：当Is非为0时，电路开始工作，但若无有效的信号（即全部为1）此时输出虽然为111，但是Os为0，表示输出的是无效信号，即<strong>电路工作，但无有效编码输入</strong>。</li>
<li>Oex意为<strong>功能有效开关</strong>：当Is非为0，Os为1时，Oex为0，表示<strong>电路工作，且有有效编码输入</strong></li>
</ul>
<p><strong>拓展</strong>（待填坑）</p>
<p>两片8-3编码器拓展成一片16-4编码器</p>
<p>解释：</p>
<h4 id="分配器（和选择器相反）"><a href="#分配器（和选择器相反）" class="headerlink" title="分配器（和选择器相反）"></a>分配器（和选择器相反）</h4><p>元件图反过来，表达式和选择器相同，功能表相似。会选择器就会分配器。</p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230414002346610.png" alt="image-20230414002346610"></p>
<h4 id="加法器"><a href="#加法器" class="headerlink" title="加法器"></a>加法器</h4><h5 id="串行进位加法器（注意逻辑表达式即可）"><a href="#串行进位加法器（注意逻辑表达式即可）" class="headerlink" title="串行进位加法器（注意逻辑表达式即可）"></a>串行进位加法器（注意逻辑表达式即可）</h5><p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230414003049711.png" alt="image-20230414003049711"></p>
<p><strong>应用：</strong>（没时间就不看，这里不重要！）</p>
<p><strong>实现减法器和加法器</strong></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230414003955720.png" alt="image-20230414003955720"></p>
<p>M为控制信号，当M为0时，为加法器，当M为1时，为减法器。</p>
<p><strong>8421转换为余3码：</strong></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230414005127923.png" alt="image-20230414005127923"></p>
<h5 id="超前进位加法器（没见考过）"><a href="#超前进位加法器（没见考过）" class="headerlink" title="超前进位加法器（没见考过）"></a>超前进位加法器（没见考过）</h5><h4 id="比较器（考过输出表达式）"><a href="#比较器（考过输出表达式）" class="headerlink" title="比较器（考过输出表达式）"></a>比较器（考过输出表达式）</h4><h5 id="一位同比较器"><a href="#一位同比较器" class="headerlink" title="一位同比较器"></a>一位同比较器</h5><p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230414004512690.png" alt="image-20230414004512690"></p>
<p>多位的话用或非门连接各个部分即可</p>
<h5 id="多位数大小比较器（单位比较器可以通过多位实现，只使多位比较器的i-1判等位有效即可）"><a href="#多位数大小比较器（单位比较器可以通过多位实现，只使多位比较器的i-1判等位有效即可）" class="headerlink" title="多位数大小比较器（单位比较器可以通过多位实现，只使多位比较器的i-1判等位有效即可）"></a>多位数大小比较器（单位比较器可以通过多位实现，只使多位比较器的i-1判等位有效即可）</h5><p>一位：（只看逻辑符号和表达式就行！！）</p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230414004640857.png" alt="image-20230414004640857"></p>
<p>多位：</p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412215310620.png" alt="image-20230412215310620"></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230414003801308.png" alt="image-20230414003801308"></p>
<p><strong>拓展</strong></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230414003726239.png" alt="image-20230414003726239"></p>
<h2 id="第四章——触发器"><a href="#第四章——触发器" class="headerlink" title="第四章——触发器"></a>第四章——触发器</h2><p><strong>重点是触发器的功能，触发状态，转移方程</strong></p>
<p>结构和原理了解即可，不了解也无关紧要，<strong>看得懂输入输出</strong>即可</p>
<h3 id="基本RS触发器"><a href="#基本RS触发器" class="headerlink" title="基本RS触发器"></a>基本RS触发器</h3><p><strong>结构和原理：</strong></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412212216821.png" alt="image-20230412212216821"></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412212324383.png" alt="image-20230412212324383"></p>
<p><strong>逻辑功能描述</strong></p>
<ul>
<li>真值表（功能表）</li>
<li>状态转移表</li>
<li>状态方程</li>
<li>状态转移图</li>
<li>波形图</li>
</ul>
<h3 id="钟控触发器"><a href="#钟控触发器" class="headerlink" title="钟控触发器"></a>钟控触发器</h3><p>CP控制信号：CP=0，维持；CP=1，启动（高电平触发）</p>
<p>关键是记住<strong>状态转移方程</strong>，特别是<strong>JK触发器</strong>，其他的都比较ez</p>
<p><strong>钟控RS</strong></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412212620179.png" alt="image-20230412212620179"></p>
<p><strong>钟控D</strong></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412212730789.png" alt="image-20230412212730789"></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412212743286.png" alt="image-20230412212743286"></p>
<p><strong>钟控T</strong></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412212925780.png" alt="image-20230412212925780"></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412212939584.png" alt="image-20230412212939584"></p>
<p><strong>钟控JK</strong></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412212847601.png" alt="image-20230412212847601"></p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412212905635.png" alt="image-20230412212905635"></p>
<p><strong>触发器的触发方式</strong></p>
<p>电平触发方式</p>
<p>边沿触发方式</p>
<h3 id="边沿触发器（和主从JK一起记，因为主从JK基本不用了）"><a href="#边沿触发器（和主从JK一起记，因为主从JK基本不用了）" class="headerlink" title="边沿触发器（和主从JK一起记，因为主从JK基本不用了）"></a>边沿触发器（和主从JK一起记，因为主从JK基本不用了）</h3><p>异步信号（以下仅列出功能，注意是低电平还是高电平）</p>
<p>Rd有效：置0</p>
<p>Sd有效：置1</p>
<p><strong>边沿JK触发器</strong></p>
<p>注意：</p>
<ul>
<li>主从JK触发器的一次翻转：如果在<strong>CP为1期间</strong>，<strong>JK信号发生改变</strong>，由于主触发器无法改变，所以当下降沿到来之时，输出信号会根据主触发器的信号而改变。但是边沿JK触发器不会有这种现象</li>
<li>考试的时候会把输出端接到JK端等等<strong>乱飞线操作</strong>，但一般都会给初始状态，记住状态转移方程或者记住J置1，K置0，异步信号优先，<strong>细心判断</strong>即可</li>
</ul>
<p><strong>维持阻塞D触发器</strong></p>
<p>可以进行分频</p>
<p><img src="/2023/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/.././%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0/image-20230412213130328.png" alt="image-20230412213130328"></p>
]]></content>
      <categories>
        <category>inClassLearning</category>
      </categories>
      <tags>
        <tag>Digital circuits</tag>
      </tags>
  </entry>
</search>
